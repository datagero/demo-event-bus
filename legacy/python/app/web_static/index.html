<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Queue Quest</title>
  <style>
    :root { --bg:#0b1020; --panel:#121a33; --muted:#8aa0c7; --text:#e7eeff; --ok:#2ecc71; --warn:#f1c40f; --err:#e74c3c; --info:#3498db; --accent:#9b59b6; }
    * { box-sizing: border-box; }
    body { background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; }
    header { padding: 16px 20px; background: #0e162b; border-bottom: 1px solid #1e2a4d; display:flex; justify-content:space-between; align-items:center; }
    h1 { margin: 0; font-size: 20px; letter-spacing: .5px; }
    header button { padding:8px 12px; border-radius:8px; border:1px solid #32406a; background:#1c2950; color:var(--text); cursor:pointer; }
    main { padding: 20px; }
    .grid { display: grid; grid-template-columns: 300px 1fr 340px 300px; gap: 16px; }
    .card { background: var(--panel); border: 1px solid #1e2a4d; border-radius: 10px; padding: 12px; }
    .card h3 { margin: 6px 0 10px; font-size: 14px; color: var(--muted); text-transform: uppercase; letter-spacing: .6px; }
    label { font-size: 12px; color: var(--muted); display: block; margin: 6px 0 2px; }
    input { width: 100%; padding: 8px; border-radius: 8px; border: 1px solid #32406a; background: #0e162b; color: var(--text); }
    button { margin-top: 8px; width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #32406a; background: #1c2950; color: var(--text); cursor: pointer; }
    button:hover { background: #233368; }
    .two { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }

    /* Quest board */
    .quests { display:grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap:10px; }
    .quest { border:1px solid #2a3863; background:#0e162b; border-radius:10px; padding:10px; position:relative; overflow:hidden; }
    .quest .title { font-weight:700; font-size:14px; margin-bottom:4px; display:flex; align-items:center; gap:6px; }
    .quest .meta { font-size:12px; color:var(--muted); }
    .quest .progress { margin-top:8px; height:8px; background:#0b1326; border:1px solid #1e2a4d; border-radius:999px; overflow:hidden; }
    .quest .bar { height:100%; width:0%; background:linear-gradient(90deg, #2ecc71, #9b59b6); transition: width .1s linear; }
    .quest.done .bar { background: #2ecc71; }
    .quest.fail .bar { background: #e74c3c; }
    .quest.unrout .bar { background: #7a2929; }
    #reset-app.fixed { position: fixed; top: 12px; right: 12px; z-index: 100; padding:10px 12px; border:2px solid #7a2929; background:#4b1616; }

    /* Roster */
    .pill { padding: 8px 10px; border: 1px solid #2a3863; background: #0e162b; border-radius: 12px; margin: 4px; display: block; cursor: pointer; }
    .pill.selected { border-color: #6fe0a0; box-shadow: 0 0 0 1px #6fe0a0 inset; }
    .pill.go-worker { border-left: 3px solid #00d4ff; }
    .pill.python-worker { border-left: 3px solid #ffd43b; }  /* Kept for future Python support */
    .type-badge { font-size: 12px; margin-left: 4px; }
    .dot { width:10px; height:10px; border-radius:50%; background:#4b4b4b; display:inline-block; }
    .dot.online { background:#2ecc71; }
    .dot.reconnecting { background:#f1c40f; }
    .skill { font-size:11px; padding:2px 6px; border-radius:999px; border:1px solid #2a3863; background:#0b1326; }
    .tiny-btn { padding: 1px 5px; font-size: 11px; border-radius: 6px; border: 1px solid #32406a; background:#1c2950; color: var(--text); cursor:pointer; }
    .roster-wrap { display: grid; grid-template-columns: 1fr; gap: 6px; align-items:start; }
    .pill .name { max-width: 110px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; display:inline-block; }
    .pill .skills { display:inline-flex; gap:4px; max-width: 160px; overflow: hidden; }
    .pill .stats { min-width: 160px; text-align: left; font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }
    .pill .controls { display:inline-flex; gap:6px; }
    .pill .line1, .pill .line2 { display:flex; align-items:center; justify-content:space-between; }
    .pill .line1 { gap:8px; }
    .pill .line2 { gap:8px; margin-top:4px; }
    .bio { position: relative; border: 1px solid #2a3863; background:#0e162b; border-radius:8px; padding:8px; font-size:12px; color: var(--muted); }
    .bio .name { color: var(--text); font-weight:600; }
    .bio .conf { display:block; margin-top:2px; color: var(--muted); }
    .bio .desc { display:block; margin-top:4px; color: var(--muted); }
    .bio .bubble { display:none; position:absolute; left:100%; top:50%; transform: translate(12px,-50%); width:260px; background:#0e162b; border:1px solid #8ec6ff; border-radius:8px; padding:10px; box-shadow:0 8px 24px rgba(0,0,0,.5); z-index:30; }
    .bio:hover .bubble { display:block; }

    /* Leaderboard */
    .scores { display: flex; flex-direction:column; gap:6px; }
    .score-row { display:flex; justify-content:space-between; gap:10px; padding:6px 10px; border:1px solid #2a3863; border-radius:8px; background:#0e162b; }
    .badge { font-size:11px; padding:2px 6px; border-radius:999px; border:1px solid #7a601e; background:#4b3c12; color:#ffd26f; margin-left:6px; }
    .mini-btn { padding: 0 3px; line-height: 1; font-size: 10px; border-radius: 4px; border: 1px solid #32406a; background:#1c2950; color: var(--text); cursor: pointer; margin-right: 6px; display:inline-flex; align-items:center; justify-content:center; }
    .medal { font-size:14px; }

    /* Quest log */
    .feed { height: 200px; overflow: auto; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; background: #0e162b; border: 1px solid #1e2a4d; border-radius: 8px; padding: 8px; }
    .row { display: flex; gap: 8px; align-items: center; margin-bottom: 4px; }
    .tag { padding: 2px 6px; border-radius: 999px; font-size: 11px; }
    .tag.info { background: #143a56; color: #8ec6ff; border: 1px solid #215b83; }
    .tag.ok { background: #0f3b2a; color: #6fe0a0; border: 1px solid #1e6a4f; }
    .tag.warn { background: #4b3c12; color: #ffd26f; border: 1px solid #7a601e; }
    .tag.err { background: #4b1616; color: #ff9b9b; border: 1px solid #7a2929; }
    .muted { color: var(--muted); }
    /* Legend bubble */
    .legend { position: relative; display: inline-block; }
    .legend .bubble { display: none; position: absolute; left: 100%; top: 50%; transform: translate(12px, -50%); background: #0e162b; border: 1px solid #8ec6ff; color: var(--text); padding: 10px 12px; border-radius: 8px; font-size: 12px; width: 320px; z-index: 20; box-shadow: 0 8px 24px rgba(0,0,0,.5); }
    .legend:hover .bubble { display: block; }
    .active { outline: 2px solid #6fe0a0; box-shadow: 0 0 0 1px #6fe0a0 inset; }

    /* Bio add pulse */
    .bio.added { outline: 2px solid #6fe0a0; box-shadow: 0 0 0 2px rgba(111,224,160,.3); transition: box-shadow .3s ease; }

    /* Help modal */
    .modal { position:fixed; inset:0; display:none; background:rgba(0,0,0,.5); align-items:center; justify-content:center; }
    .modal .inner { width: min(800px, 92vw); background: var(--panel); border:1px solid #1e2a4d; border-radius:12px; padding:16px; }
    .modal.show { display:flex; }
    .help li { margin-bottom:6px; }

    /* Card Game Styles */
    .card-green { background: #27ae60; color: white; }
    .card-yellow { background: #f39c12; color: white; }
    .card-red { background: #e74c3c; color: white; }
    .card-black { background: #2c3e50; color: white; }
    
    .effect-pill { 
      padding: 4px 8px; 
      border-radius: 12px; 
      font-size: 12px; 
      background: #34495e; 
      color: #ecf0f1; 
      display: flex; 
      align-items: center; 
      gap: 4px;
    }
    
    .effect-green { background: #27ae60; }
    .effect-yellow { background: #f39c12; }
    .effect-red { background: #e74c3c; }
    .effect-black { background: #2c3e50; }
  </style>
</head>
<body>
  <header>
    <h1>üß≠ Queue Quest</h1>
    <div style="display:flex; gap:8px; align-items:center">
      <div id="worker-status" style="font-size:12px; padding:4px 8px; border-radius:6px; background:#1c2950; border:1px solid #32406a">
        <span id="worker-mode">üöÄ Go workers ready</span>
      </div>
      <div style="display:flex; gap:8px; align-items:center">
        <label style="font-size:12px; color:#8aa0c7; display:flex; gap:4px; align-items:center">
          <input type="checkbox" id="raw-mode-toggle" style="width:auto">
          Raw RabbitMQ Mode
        </label>
        <label style="font-size:12px; color:#8aa0c7; display:flex; gap:4px; align-items:center">
          <input type="checkbox" id="rmq-derived-toggle" style="width:auto" checked>
          üê∞ Direct RabbitMQ APIs
        </label>
        <button id="help-btn">How it works</button>
        <button id="scores-btn">Leaderboard</button>
      </div>
    </div>
  </header>
  <main>
    <div class="card" style="margin-bottom:12px; display:flex; gap:12px; align-items:flex-end; flex-wrap:wrap">
      <div>
        <label>Routing</label>
        <div class="two" style="min-width:320px">
          <button id="route-skill" title="Single delivery: one shared queue per skill; only one player receives each message.">Skill-based (shared)</button>
          <button id="route-player" title="Multi delivery: each player queue receives its own copy; unskilled requeue.">Player-based (fanout)</button>
        </div>
      </div>
      <div>
        <label>Wave</label>
        <div class="two" style="min-width:320px">
          <div>
            <label style="display:block; font-size:12px; color:#8aa0c7">Count</label>
            <input id="count" type="number" value="20" min="1" step="1">
          </div>
          <div>
            <label style="display:block; font-size:12px; color:#8aa0c7">Delay (sec)</label>
            <input id="delay" type="number" value="0.1" min="0" step="0.05">
          </div>
        </div>
      </div>
      <div style="align-self:flex-end; display:flex; gap:8px; align-items:flex-end">
        <button id="start-master" style="width:auto">Start Quest Wave</button>
        <button id="reset-app" class="mini-btn" style="width:auto; padding:10px 12px; border:2px solid #7a2929; background:#4b1616">Reset</button>
      </div>
      <div style="display:flex; gap:6px; align-items:flex-end">
        <label style="display:block; font-size:12px; color:#8aa0c7">Quick Play</label>
        <button id="qp-quick" style="width:auto" title="Recruit Alice+Bob and start a wave">Quick Start</button>
        <button class="qp-preset" data-count="10" data-delay="0.3" style="width:auto" title="10 quests @ 0.3s">Chill</button>
        <button class="qp-preset" data-count="20" data-delay="0.1" style="width:auto" title="20 quests @ 0.1s">Normal</button>
        <button class="qp-preset" data-count="40" data-delay="0.05" style="width:auto" title="40 quests @ 0.05s">Chaos</button>
      </div>
      <div style="margin-left:auto; display:flex; gap:6px; align-items:flex-end">
        <label style="display:block; font-size:12px; color:#8aa0c7">Send one</label>
        <button class="send-one" data-type="gather" style="width:auto">gather</button>
        <button class="send-one" data-type="slay" style="width:auto">slay</button>
        <button class="send-one" data-type="escort" style="width:auto">escort</button>
      </div>
    </div>
      <div class="card" id="statusbar" style="margin-bottom:12px; display:flex; gap:12px; align-items:center; justify-content:space-between">
      <div>Routing: <span id="status-routing" class="tag info">?</span></div>
      <div>Wave: <span id="status-wave" class="tag info">count=20 ¬∑ delay=0.1s</span></div>
      <div>Pending: <span id="status-pending" class="tag warn">0</span></div>
        <div>Expired: <span id="status-expired" class="tag err">0</span></div>
        <div>Broker: <span id="status-broker" class="tag info">ready=‚Äì ¬∑ unacked=‚Äì</span> <button id="sync-broker" class="mini-btn" title="Sync broker KPIs">‚Üª</button></div>
    </div>

    <!-- Card Game Section -->
    <div class="card" id="cardgame-panel" style="margin-bottom:12px; border: 2px solid #9b59b6;">
      <h3>üÉè Card Quest Challenge</h3>
      <div style="display:flex; gap:12px; align-items:center; justify-content:space-between; margin-bottom:12px;">
        <div id="cardgame-controls" style="display:flex; gap:8px; align-items:center;">
          <button id="start-cardgame" style="background:#2ecc71; border-color:#27ae60;">Start Challenge</button>
          <button id="stop-cardgame" style="background:#e74c3c; border-color:#c0392b;" disabled>Stop</button>
          <button id="draw-card" style="background:#f39c12; border-color:#e67e22;" disabled>Manual Draw</button>
        </div>
        <div id="cardgame-status" style="display:flex; gap:12px; align-items:center;">
          <div>Score: <span id="game-score" class="tag info">1000</span></div>
          <div>Next Card: <span id="card-timer" class="tag warn">--</span></div>
          <div>Effects: <span id="active-effects" class="tag">0</span></div>
        </div>
      </div>
      
      <div id="current-card" style="display:none; padding:12px; border:1px solid #34495e; border-radius:8px; margin-bottom:12px;">
        <div style="display:flex; gap:12px; align-items:flex-start;">
          <div id="card-color-badge" class="tag">GREEN</div>
          <div style="flex:1;">
            <h4 id="card-name" style="margin:0 0 4px 0;">Card Name</h4>
            <p id="card-desc" style="margin:0; font-size:14px; color:#8aa0c7;">Card description...</p>
          </div>
          <div id="card-duration" style="color:#f39c12; font-weight:bold;">15s</div>
        </div>
      </div>
      
      <div id="active-effects-list" style="display:none;">
        <h4 style="margin:8px 0 4px 0; font-size:14px; color:#8aa0c7;">Active Effects:</h4>
        <div id="effects-container" style="display:flex; gap:6px; flex-wrap:wrap;"></div>
      </div>
    </div>
    <div class="grid">
      <div class="card">
        <h3>Controls ‚öôÔ∏è</h3>
        <h3>Scenarios üß™</h3>
        <div class="two">
          <button id="sc-late-bind" title="Messages published before queue exists ‚Üí worker creates queue ‚Üí backlog management">Late-bind escort (backlog handoff)</button>
          <button id="sc-routing" title="Compare skill-based vs player-based routing behavior">Routing comparison</button>
        </div>

        <div class="muted" style="margin-top:6px; font-size:12px">Educational scenarios that demonstrate unique RabbitMQ behaviors.</div>
        <hr style="border-color:#1e2a4d; margin:10px 0">
        <h3>Enhanced Message Chaos üå™Ô∏è</h3>
        <div style="margin-bottom:12px">
          <div style="margin-bottom:8px">
            <label style="display:block; font-size:12px; color:#8aa0c7; margin-bottom:4px">Action</label>
            <select id="chaos-action" style="width:100%; padding:6px; background:var(--panel); border:1px solid #34495e; color:var(--text); border-radius:4px">
              <optgroup label="üê∞ RabbitMQ-Native Actions" style="background:#1e2a4d; color:#8aa0c7">
                <option value="rmq_delete_queue">Delete Queue (Direct RMQ API)</option>
                <option value="rmq_unbind_queue">Unbind Queue (Break Routing)</option>
                <option value="rmq_block_connection">Close AMQP Connection</option>
                <option value="rmq_purge_queue">Purge Queue Messages</option>
              </optgroup>
              <optgroup label="üîß Legacy App-Level Actions" style="background:#2c1810; color:#d4af37">
                <option value="drop">Drop (real disconnect + auto-reconnect)</option>
                <option value="requeue">Requeue (NACK with requeue)</option>
                <option value="dlq">DLQ (NACK to dead letter)</option>
                <option value="fail_early">Fail Early (immediate fail)</option>
                <option value="disconnect">Disconnect (player offline)</option>
                <option value="pause">Pause (5 second pause)</option>
              </optgroup>
            </select>
          </div>
          
          <div class="two" style="margin-bottom:8px">
            <div>
              <label style="display:block; font-size:12px; color:#8aa0c7; margin-bottom:4px">Target Player</label>
              <select id="chaos-player" style="width:100%; padding:6px; background:var(--panel); border:1px solid #34495e; color:var(--text); border-radius:4px">
                <option value="">Any Player</option>
              </select>
            </div>
            <div>
              <label style="display:block; font-size:12px; color:#8aa0c7; margin-bottom:4px">Target Queue/Type</label>
              <select id="chaos-quest-type" style="width:100%; padding:6px; background:var(--panel); border:1px solid #34495e; color:var(--text); border-radius:4px">
                <option value="">Any Quest</option>
                <option value="gather">Gather</option>
                <option value="slay">Slay</option>
                <option value="escort">Escort</option>
                <option value="game.skill.gather.q">Queue: game.skill.gather.q</option>
                <option value="game.skill.slay.q">Queue: game.skill.slay.q</option>
                <option value="web.scoreboard.q">Queue: web.scoreboard.q</option>
              </select>
            </div>
          </div>
          
          <div style="margin-bottom:8px">
            <label style="display:flex; align-items:center; gap:6px; font-size:12px; color:#8aa0c7">
              <input type="checkbox" id="chaos-auto-trigger">
              Auto-publish messages after delay
            </label>
            <div id="chaos-auto-settings" style="display:none; margin-top:6px; padding-left:20px">
              <div class="two">
                <div>
                  <label style="font-size:11px; color:#8aa0c7">Delay (sec)</label>
                  <input type="number" id="chaos-delay" value="2" min="0.1" step="0.1" style="width:100%; padding:4px; background:var(--panel); border:1px solid #34495e; color:var(--text); border-radius:4px">
                </div>
                <div>
                  <label style="font-size:11px; color:#8aa0c7">Count</label>
                  <input type="number" id="chaos-count" value="1" min="1" step="1" style="width:100%; padding:4px; background:var(--panel); border:1px solid #34495e; color:var(--text); border-radius:4px">
                </div>
              </div>
            </div>
          </div>
          
          <div class="two" style="gap:8px">
            <button id="chaos-arm" style="background:#e74c3c; border-color:#c0392b">Arm Chaos</button>
            <button id="chaos-disarm" style="background:#7f8c8d; border-color:#6c7b7d">Disarm</button>
          </div>
          
          <div id="chaos-status" style="margin-top:8px; padding:6px; background:#2c3e50; border-radius:4px; font-size:12px; display:none">
            <div>Status: <span id="chaos-status-text">Disarmed</span></div>
          </div>
        </div>
        <div class="muted" style="font-size:12px">Powerful chaos system: target specific players/quests, auto-trigger scenarios.</div>
        <hr style="border-color:#1e2a4d; margin:10px 0">
        <h3>Messages üì¨</h3>
        <div style="display:flex; gap:6px; flex-wrap:wrap; align-items:center">
          <button id="tab-pending" class="mini-btn" title="Pending">Pending</button>
          <button id="tab-failed" class="mini-btn" title="Failed">Failed</button>
          <button id="tab-dlq" class="mini-btn" title="DLQ">DLQ</button>
          <button id="tab-unrout" class="mini-btn" title="Unroutable" style="cursor:pointer">Unroutable</button>
          <span style="margin-left:auto"></span>
          <div style="display:inline-flex; gap:6px; align-items:center">
            <label style="font-size:12px; color:#8aa0c7">TTL (ms)</label>
            <input id="ttl-skill" placeholder="skill" style="width:80px" />
            <input id="ttl-ms" type="number" value="30000" min="1000" step="1000" style="width:100px" />
            <button id="ttl-set" class="mini-btn" title="Set TTL">Set</button>
          </div>
          <button id="msg-reissue-all" class="mini-btn" title="Reissue all">Reissue all</button>
          <button id="msg-purge" class="mini-btn" title="Purge (DLQ only)">Purge</button>
          <button id="msg-show-all" class="mini-btn" title="Show all items">Show all</button>
        </div>
        <div id="msg-list" class="muted" style="margin-top:6px; font-size:12px"></div>
        <div style="margin-top:10px">
          <h3 style="margin:6px 0">Broker Routes</h3>
          <div id="routes" class="muted" style="font-size:12px"></div>
          <button id="refresh-routes" class="mini-btn" title="Refresh routes">‚Üª</button>
        </div>
      </div>

      <div class="card">
        <h3>Quest Board <button id="toggle-quests" style="width:auto; float:right">Toggle</button></h3>
        <div style="display:flex; justify-content:space-between; align-items:center; margin:6px 0">
          <div id="type-metrics" class="muted"></div>
          <div class="legend" style="margin-left:auto"><button style="width:auto">Legend</button><div class="bubble"><strong>Ready</strong>: in queue, not delivered.<br/><strong>Unacked</strong>: delivered to a player; processing until ack.<br/>If player disconnects before ack, it returns to Ready.</div></div>
        </div>
        <details open>
          <summary>gather</summary>
          <div id="quests-gather" class="quests"></div>
        </details>
        <details open>
          <summary>slay</summary>
          <div id="quests-slay" class="quests"></div>
        </details>
        <details open>
          <summary>escort</summary>
          <div id="quests-escort" class="quests"></div>
        </details>
        <div style="display:flex; justify-content:space-between; align-items:center; margin-top:12px">
          <h3 style="margin:0">Quest Log</h3>
          <button id="clear-feed" style="width:auto">Clear</button>
        </div>
        <div id="feed" class="feed"></div>
      </div>

      <div class="card" id="player-pane">
        <h3>Activity</h3>
        <canvas id="activity" width="300" height="80" style="width:100%; background:#0e162b; border:1px solid #1e2a4d; border-radius:8px"></canvas>
        <h3 style="margin-top:12px">Throughput <button id="throughput-help" class="tiny-btn" style="margin-left:4px" title="Click for explanation">?</button></h3>
        <canvas id="throughput" width="300" height="100" style="width:100%; background:#0e162b; border:1px solid #1e2a4d; border-radius:8px"></canvas>
        <div id="throughput-legend" class="muted" style="margin-top:6px; font-size:12px"></div>
        <h3 style="margin-top:12px">Roster</h3>
        <div id="roster"></div>
        <div class="muted" style="margin-top:6px; font-size:12px">
          üöÄ Go workers (blue border)<br>
          Tip: Click a player pill to select; use the tiny buttons on each pill for Pause/Resume/Crash.
        </div>
        <hr style="border-color:#1e2a4d; margin:10px 8px">
        <h3>Recruit üë•</h3>
        <div style="display:flex; gap:8px; flex-wrap:wrap; margin-bottom:8px">
          <button id="quick-alice-bob">Quickstart: Alice+Bob</button>
          <button id="add-random">Add Random Player</button>
          <button id="toggle-custom">Custom Player‚Ä¶</button>
        </div>
        <div id="custom-form" style="display:none; margin-top:8px">
          <label>Name</label>
          <input id="player" type="text" value="carol">
          <label>Skills</label>
          <div class="two">
            <label style="display:flex; gap:6px; align-items:center"><input type="checkbox" id="sk_gather" checked> gather</label>
            <label style="display:flex; gap:6px; align-items:center"><input type="checkbox" id="sk_slay" checked> slay</label>
            <label style="display:flex; gap:6px; align-items:center"><input type="checkbox" id="sk_escort" checked> escort</label>
          </div>
          <label>Fail chance</label>
          <input id="fail" type="number" value="0.2" min="0" max="1" step="0.05">
          <div class="two">
            <div>
              <label>Speed (lower=faster)</label>
              <input id="speed" type="number" value="1.0" min="0.05" step="0.05">
            </div>
            <div>
              <label>Workers</label>
              <input id="workers" type="number" value="1" min="1" step="1">
            </div>
          </div>
          <div class="two">
            <div>
              <label>Prefetch</label>
              <input id="prefetch" type="number" value="1" min="1" step="1">
            </div>
            <div>
              <label>Chaos drop rate</label>
              <input id="drop_rate" type="number" value="0" min="0" max="1" step="0.05">
            </div>
          </div>
          <div>
            <label>Chaos skip rate</label>
            <input id="skip_rate" type="number" value="0" min="0" max="1" step="0.05">
          </div>
          <button id="start-player">Add Player</button>
        </div>
        <div class="muted" style="margin-top:6px; font-size:12px">Click a hero to recruit instantly:</div>
        <div class="bio" data-player="alice" data-skills="gather,slay" data-fail="0.2" data-speed="1.0" data-workers="1">
          <div class="name">Alice</div>
          <span class="conf">gather ¬∑ slay ¬∑ w1 ¬∑ s1.0</span>
          <span class="desc">A balanced worker for fairness and redelivery demos.</span>
          <div class="bubble">
            A balanced worker specialized in gather and slay. One worker (prefetch defaults to 1). Great for demonstrating single-delivery fairness and redelivery.
          </div>
        </div>
        <div class="bio" style="margin-top:6px" data-player="bob" data-skills="slay,escort" data-fail="0.1" data-speed="0.7" data-workers="2">
          <div class="name">Bob</div>
          <span class="conf">slay ¬∑ escort ¬∑ w2 ¬∑ s0.7</span>
          <span class="desc">A faster, concurrent worker to visualize contention and unacked.</span>
          <div class="bubble">
            A faster, concurrent worker specialized in slay and escort. Two workers for higher parallelism (watch unacked) and contention scenarios.
          </div>
        </div>
        <div class="bio" style="margin-top:6px" data-player="carol" data-skills="slay" data-fail="0.15" data-speed="0.8" data-workers="1">
          <div class="name">Carol</div>
          <span class="conf">slay ¬∑ w1 ¬∑ s0.8 ¬∑ fail 0.15</span>
          <span class="desc">A focused slayer with slightly faster speed and small failure rate.</span>
          <div class="bubble">
            Good to demonstrate competition on slay quests and failure handling.
          </div>
        </div>
        <div class="bio" style="margin-top:6px" data-player="dave" data-skills="gather,escort" data-fail="0.1" data-speed="1.3" data-workers="2">
          <div class="name">Dave</div>
          <span class="conf">gather ¬∑ escort ¬∑ w2 ¬∑ s1.3</span>
          <span class="desc">A steady multi-worker for breadth; useful to drain backlogs.</span>
          <div class="bubble">
            Shows the effect of workers>1 and higher processing time for variance.
          </div>
        </div>
        <div class="muted" style="margin-top:6px">RabbitMQ UI: http://localhost:15672</div>
      </div>

      <!-- RabbitMQ Direct Introspection Panel -->
      <div class="card" id="rabbitmq-pane">
        <h3>üê∞ RabbitMQ Direct View</h3>
        <div class="muted" style="margin-bottom:8px; font-size:12px">
          Direct RabbitMQ data - minimal abstraction for educational purposes
        </div>
        
        <!-- Queue Stats -->
        <h4 style="margin:8px 0 4px 0; font-size:13px; color:#8aa0c7">Live Queue Stats</h4>
        <div id="rmq-queue-stats" style="font-family:monospace; font-size:11px; background:#0e162b; border:1px solid #1e2a4d; border-radius:4px; padding:6px; max-height:120px; overflow-y:auto">
          <div class="muted">Connecting to RabbitMQ...</div>
        </div>
        
        <!-- Exchange Topology -->
        <h4 style="margin:8px 0 4px 0; font-size:13px; color:#8aa0c7">Exchange Bindings</h4>
        <div id="rmq-topology" style="font-family:monospace; font-size:11px; background:#0e162b; border:1px solid #1e2a4d; border-radius:4px; padding:6px; max-height:100px; overflow-y:auto">
          <div class="muted">Loading topology...</div>
        </div>
        
        <!-- Live Message Stream -->
        <h4 style="margin:8px 0 4px 0; font-size:13px; color:#8aa0c7">Live Message Stream</h4>
        <div id="rmq-live-stream" style="font-family:monospace; font-size:10px; background:#0e162b; border:1px solid #1e2a4d; border-radius:4px; padding:6px; max-height:180px; overflow-y:auto">
          <div class="muted">Connecting to live message stream...</div>
        </div>
        
        <!-- Message Peek Controls -->
        <h4 style="margin:8px 0 4px 0; font-size:13px; color:#8aa0c7">Message Peek</h4>
        <div style="display:flex; gap:6px; margin-bottom:4px">
          <select id="rmq-queue-select" style="flex:1; padding:4px; background:var(--panel); border:1px solid #34495e; color:var(--text); border-radius:4px; font-size:11px">
            <option value="">Select queue...</option>
          </select>
          <button id="rmq-peek-btn" style="width:auto; padding:4px 8px; font-size:11px">Peek</button>
        </div>
        <div id="rmq-messages" style="font-family:monospace; font-size:10px; background:#0e162b; border:1px solid #1e2a4d; border-radius:4px; padding:6px; max-height:120px; overflow-y:auto">
          <div class="muted">Select a queue and click Peek to view messages</div>
        </div>
        
        <!-- Educational Abstraction Comparison -->
        <h4 style="margin:8px 0 4px 0; font-size:13px; color:#8aa0c7">Educational Comparison</h4>
        <div style="font-size:10px; background:#0e162b; border:1px solid #1e2a4d; border-radius:4px; padding:6px">
          <div style="color:#ffd26f; margin-bottom:4px">üéØ <strong>Abstraction Layers Removed:</strong></div>
          <div style="color:#e7eeff; line-height:1.4">
            ‚ùå Internal quest state tracking<br>
            ‚ùå Server-side scoreboard aggregation<br>
            ‚ùå Manual message counting<br>
            ‚ùå Internal roster management<br>
            ‚úÖ Direct RabbitMQ queue queries<br>
            ‚úÖ Live consumer information<br>
            ‚úÖ Real-time queue depths
          </div>
          <div style="margin-top:6px; padding-top:4px; border-top:1px solid #1e2a4d">
            <div style="color:#8aa0c7; font-size:9px">
              <strong>Data Sources:</strong><br>
              <span style="color:#6fe0a0">‚úì Main APIs</span> - RabbitMQ-derived<br>
              <span style="color:#ffd26f">‚ö† Expired/Failed</span> - App-level (valid)<br>
              <span style="color:#8ec6ff">‚Ñπ Current Source:</span> <span id="current-data-source">Standard</span>
            </div>
          </div>
        </div>
        
        <!-- Raw API Access -->
        <div style="margin-top:8px; padding:6px; background:#1c2950; border:1px solid #32406a; border-radius:4px">
          <div style="font-size:11px; color:#8aa0c7; margin-bottom:4px">Direct RabbitMQ Management API:</div>
          <div style="font-size:10px; font-family:monospace">
            <a href="http://localhost:15672" target="_blank" style="color:#6fe0a0">Management UI</a> |
            <a href="/api/rabbitmq/raw/queues" target="_blank" style="color:#6fe0a0">Raw Queues</a> |
            <a href="/api/rabbitmq/raw/exchanges" target="_blank" style="color:#6fe0a0">Raw Exchanges</a> |
            <a href="/api/rabbitmq/derived/metrics" target="_blank" style="color:#6fe0a0">Derived Metrics</a>
          </div>
        </div>
      </div>

      <!-- Comprehensive DLQ Management Panel -->
      <div class="card" id="dlq-management-pane">
        <h3>‚ö∞Ô∏è Dead Letter Queue Management</h3>
        <div class="muted" style="margin-bottom:8px; font-size:12px">
          Native RabbitMQ DLQ system with specific queues for different failure types
        </div>
        
        <!-- DLQ Setup Control -->
        <div style="display:flex; gap:8px; margin-bottom:12px; align-items:center">
          <button id="dlq-setup-btn" style="width:auto; padding:6px 12px; background:#27ae60; color:white">Setup DLQ Topology</button>
          <button id="dlq-inspect-btn" style="width:auto; padding:6px 12px; background:#3498db; color:white">Inspect DLQs</button>
          <button id="dlq-replay-btn" style="width:auto; padding:6px 12px; background:#f39c12; color:white">Replay All</button>
          <button id="dlq-purge-btn" style="width:auto; padding:6px 12px; background:#e74c3c; color:white">Purge All</button>
        </div>
        
        <!-- DLQ Status Display -->
        <div id="dlq-status" style="font-family:monospace; font-size:11px; background:#0e162b; border:1px solid #1e2a4d; border-radius:4px; padding:8px; margin-bottom:8px; max-height:200px; overflow-y:auto">
          <div class="muted">Click "Setup DLQ Topology" to initialize the comprehensive DLQ system</div>
        </div>
        
        <!-- Manual DLQ Actions -->
        <h4 style="margin:8px 0 4px 0; font-size:13px; color:#8aa0c7">Manual DLQ Actions</h4>
        <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:8px">
          <div>
            <label style="display:block; font-size:11px; color:#8aa0c7; margin-bottom:2px">Send to DLQ</label>
            <select id="dlq-reason-select" style="width:100%; padding:4px; background:var(--panel); border:1px solid #34495e; color:var(--text); border-radius:4px; font-size:11px">
              <option value="rejected">Rejected (Consumer NACK)</option>
              <option value="expired">Expired (TTL exceeded)</option>
              <option value="maxlen">Max Length (Queue overflow)</option>
              <option value="delivery_limit">Delivery Limit (Too many retries)</option>
              <option value="poison">Poison Message (Malformed)</option>
              <option value="unroutable">Unroutable (No matching queue)</option>
              <option value="quarantine">Quarantine (Manual intervention)</option>
            </select>
          </div>
          <div>
            <label style="display:block; font-size:11px; color:#8aa0c7; margin-bottom:2px">Target Queue</label>
            <input id="dlq-test-message" type="text" placeholder="test.message.id" style="width:100%; padding:4px; background:var(--panel); border:1px solid #34495e; color:var(--text); border-radius:4px; font-size:11px">
          </div>
        </div>
        <button id="dlq-test-send" style="width:auto; padding:4px 8px; background:#9b59b6; color:white; font-size:11px">Send Test Message to DLQ</button>
        
        <!-- Educational DLQ Flow -->
        <h4 style="margin:12px 0 4px 0; font-size:13px; color:#8aa0c7">DLQ Flow Visualization</h4>
        <div style="font-size:10px; background:#0e162b; border:1px solid #1e2a4d; border-radius:4px; padding:8px">
          <div style="color:#ffd26f; margin-bottom:6px">üéØ <strong>Message Flow Through DLQ System:</strong></div>
          <div style="color:#e7eeff; line-height:1.6; font-family:monospace">
            üì• <span style="color:#6fe0a0">Main Queue</span> ‚Üí <span style="color:#8aa0c7">Consumer Processing</span><br>
            ‚¨áÔ∏è <span style="color:#ff9b9b">Failure/Rejection</span><br>
            üîÑ <span style="color:#ffd26f">retry.1</span> (5s TTL) ‚Üí <span style="color:#ffd26f">retry.2</span> (30s TTL) ‚Üí <span style="color:#ffd26f">retry.3</span> (5m TTL)<br>
            ‚¨áÔ∏è <span style="color:#ff9b9b">Max Retries Exceeded</span><br>
            ‚ö∞Ô∏è <span style="color:#e74c3c">Specific DLQ by Failure Type:</span><br>
            &nbsp;&nbsp;‚Ä¢ <span style="color:#ff9b9b">dlq.rejected</span> - Consumer rejections<br>
            &nbsp;&nbsp;‚Ä¢ <span style="color:#ff9b9b">dlq.expired</span> - TTL expiration<br>
            &nbsp;&nbsp;‚Ä¢ <span style="color:#ff9b9b">dlq.poison</span> - Malformed messages<br>
            &nbsp;&nbsp;‚Ä¢ <span style="color:#ff9b9b">dlq.unroutable</span> - No route available<br>
            &nbsp;&nbsp;‚Ä¢ <span style="color:#ff9b9b">quarantine</span> - Manual intervention needed
          </div>
          <div style="margin-top:8px; padding-top:6px; border-top:1px solid #1e2a4d">
            <div style="color:#8aa0c7; font-size:9px">
              <strong>Native RabbitMQ Features Used:</strong><br>
              <span style="color:#6fe0a0">‚úì x-dead-letter-exchange</span> - Routes failed messages<br>
              <span style="color:#6fe0a0">‚úì x-message-ttl</span> - Automatic retry timing<br>
              <span style="color:#6fe0a0">‚úì x-death headers</span> - Failure tracking<br>
              <span style="color:#6fe0a0">‚úì alternate-exchange</span> - Unroutable handling<br>
              <span style="color:#6fe0a0">‚úì topic routing</span> - Failure type classification
            </div>
          </div>
        </div>
      </div>
    </div>
  </main>

  <div id="help" class="modal">
    <div class="inner">
      <h3>How it works</h3>
      <ul class="help">
        <li>Master publishes quests to <code>game.quest.&lt;type&gt;</code> with difficulty/weight/points.</li>
        <li>Players consume from shared per-skill queues (Skill mode) or per-player queues (Player mode).</li>
        <li>On ACCEPT, the message is <strong>Unacked</strong> until ack; on SKIP, it is NACK requeue and returns to <strong>Ready</strong>.</li>
        <li>Results publish to <code>game.quest.&lt;type&gt;.done|fail</code>; scoreboard totals points live.</li>
        <li>Crash before ack ‚áí message returns to Ready (redelivery). Prefetch controls in-flight concurrency.</li>
        <li>DLQ: NACK requeue=false sends to a dead-letter queue for triage. Reissue or purge from Messages panel.</li>
      </ul>
      <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:10px">
        <button id="close-help" style="width:auto">Close</button>
      </div>
    </div>
  </div>
  <div id="scores-modal" class="modal">
    <div class="inner">
      <h3>Leaderboard üèÜ</h3>
      <div id="scores" class="scores"></div>
      <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:10px">
        <button id="close-scores" style="width:auto">Close</button>
      </div>
    </div>
  </div>
  <div id="quest-modal" class="modal">
    <div class="inner">
      <h3>Quest details</h3>
      <div id="qm-header" class="muted" style="margin-bottom:6px"></div>
      <div id="qm-body" class="feed" style="height:240px"></div>
      <div style="display:flex; gap:8px; justify-content:flex-end; margin-top:10px">
        <button id="qm-close" style="width:auto">Close</button>
      </div>
    </div>
  </div>

  <script>
    const feed = document.getElementById('feed');
    // scores is rendered inside the scores modal; guard if absent
    const rosterDiv = document.getElementById('roster');
    const questsByType = {
      gather: document.getElementById('quests-gather'),
      slay: document.getElementById('quests-slay'),
      escort: document.getElementById('quests-escort'),
    };
    const typeMetricsDiv = document.getElementById('type-metrics');
    const historyByQuest = {}; // id -> [{ts,type,text}]
    const reissueAlias = {}; // newId -> originalId
    function resolveAlias(id){
      let cur = id; const seen = new Set();
      while (reissueAlias[cur] && !seen.has(cur)) { seen.add(cur); cur = reissueAlias[cur]; }
      return cur;
    }

    const quests = {}; // questId -> {el, start, dur}
    function questId(p){
      const id = p.case_id || p.quest_id || p.id;
      if (p.reissue_of){ reissueAlias[id] = p.reissue_of; }
      return resolveAlias(id);
    }

    function medal(idx){ return idx===0?'ü•á':idx===1?'ü•à':idx===2?'ü•â':'üéØ'; }

    function line(tagClass, title, body) {
      const row = document.createElement('div'); row.className = 'row';
      const tag = document.createElement('span'); tag.className = `tag ${tagClass}`; tag.textContent = title;
      const span = document.createElement('span'); span.textContent = body;
      row.appendChild(tag); row.appendChild(span); return row;
    }
    const seenSkips = new Set();
    function appendFeed(tagClass, title, body, dedupeKey) {
      if (dedupeKey && seenSkips.has(dedupeKey)) return;
      if (dedupeKey) seenSkips.add(dedupeKey);
      feed.appendChild(line(tagClass, title, body));
      // cap at ~300 lines
      while (feed.childElementCount > 300) feed.removeChild(feed.firstChild);
      feed.scrollTop = feed.scrollHeight;
    }

    function renderScores(snap) {
      const scores = document.getElementById('scores');
      if (!scores) return;
      const s = snap.scoreboard || {}; const f = snap.fails || {};
      const entries = Object.entries(s).sort((a,b)=>b[1]-a[1]);
      const icon = (i)=> i===0?'ü•á':(i===1?'ü•à':(i===2?'ü•â':'üéØ'));
      scores.innerHTML = entries.length ? entries.map(([p,pts],i) => {
        const fail = f[p] || 0; const st = (snap.player_stats&&snap.player_stats[p])||{inflight:0};
        const meta = (snap.roster&&snap.roster[p])||{}; const spd = meta.speed_multiplier!=null?meta.speed_multiplier:1.0; const wrk = meta.workers!=null?meta.workers:1;
        const title = `${p} ‚Äî workers:${wrk} speed:${spd}\npoints:${pts} fails:${fail} inflight(unacked):${st.inflight}`;
        return `<div class="score-row" title="${title}"><span>${icon(i)} ${p}${st.inflight?` <span class='badge'>${st.inflight} unacked</span>`:''}</span><span>${pts} pts${fail?` ¬∑ fails:${fail}`:''}</span></div>`;
      }).join('') : '<div class="muted">No scores yet</div>';
    }

    const rosterState = {}; // name -> {skills, fail_pct, status, speed_multiplier, workers}
    let activePlayer = null;
    function renderRoster(snap) {
      // Defensively update rosterState only when a snapshot is explicitly provided.
      // This prevents other WebSocket messages from accidentally clearing the roster.
      if (snap && snap.roster) {
        const r = snap.roster;
        // Synchronize our client-side state with the incoming snapshot.
        Object.keys(rosterState).forEach(k => { if (!(k in r)) delete rosterState[k]; });
        Object.entries(r).forEach(([name,meta]) => { rosterState[name] = {...(rosterState[name]||{}), ...meta}; });
      }

      // Always re-render from the definitive client-side rosterState.
      document.querySelectorAll('.bio').forEach(b => {
        const pname = b.getAttribute('data-player');
        if (pname && !(pname in rosterState)) {
          b.classList.remove('added');
        }
      });
      
      const ordered = Object.entries(rosterState).sort((a,b)=>a[0].localeCompare(b[0]));
      let html = ordered.map(([name,meta]) => {
        const status = meta.status||'offline';
        const dotClass = status==='online'?'online':(status==='reconnecting'?'reconnecting':'');
        const ps = (snap.player_stats&&snap.player_stats[name])||{accepted:0,completed:0,failed:0,inflight:0};
        const spd = meta.speed_multiplier!=null ? Number(meta.speed_multiplier) : 1.0;
        const wrk = meta.workers!=null ? meta.workers : 1;
        const spdTxt = spd.toFixed(2);
        const failTxt = (meta.fail_pct!=null ? meta.fail_pct : 0).toFixed(2);
        const workerType = meta.type || 'go';  // Default to Go workers in Go-only system
        const typeIcon = workerType === 'go' ? 'üöÄ' : 'üêç';
        const typeLabel = workerType === 'go' ? 'Go' : 'Python';
        const tip = `${name} ‚Äî ${status} (${typeLabel})\nskills: ${(meta.skills||[]).join(',')}\nworkers: ${String(wrk).padStart(2,' ')}  speed: ${spdTxt}\naccepted: ${String(ps.accepted).padStart(3,' ')}  completed: ${String(ps.completed).padStart(3,' ')}  failed: ${String(ps.failed).padStart(3,' ')}\ninflight (unacked): ${String(ps.inflight).padStart(2,' ')}`;
        const skills = (meta.skills||[]).map(s=>`<span class='skill'>${s}</span>`).join(' ');
        const sel = (name===activePlayer)?' selected':'';
        const typeClass = workerType === 'go' ? 'go-worker' : 'python-worker';
        return `<span class="pill ${typeClass}${sel}" data-name="${name}" title="${tip}">
          <div class="line1"><span class="dot ${dotClass}"></span><span class="name">${name}</span><span class="type-badge">${typeIcon}</span><span>&nbsp;¬∑&nbsp;</span><span class="skills">${skills}</span></div>
          <div class="line2"><span class="stats">w${String(wrk).padStart(2,' ')} ¬∑ s${spdTxt} ¬∑ f${failTxt}</span>
            <span class="controls">
              <button class="tiny-btn player-action" data-action="pause" data-name="${name}" title="Disconnect (real disconnect - stays offline)">‚è∏</button>
              <button class="tiny-btn player-action" data-action="resume" data-name="${name}" title="Reconnect (restart worker)">‚ñ∂</button>
              <button class="tiny-btn player-action" data-action="crash" data-name="${name}" title="Crash + Auto-reconnect (3s delay)">‚ö°</button>
              <button class="tiny-btn player-delete" data-name="${name}" title="Delete">üóë</button>
            </span>
          </div>
        </span>`;
      }).join(' ');
      rosterDiv.innerHTML = html ? `<div class='roster-wrap'>${html}</div>` : '<div class="muted">No players yet</div>';
    }

    function ensureQuestCard(p) {
      const rawId = p.case_id || p.quest_id || p.id;
      const id = questId(p); if (!id) return { el: null, start: Date.now(), dur: 1000 };
      // Dedupe: if a transient card was created with rawId before alias, remove it
      if (rawId && rawId !== id && quests[rawId] && quests[id]) {
        const dup = quests[rawId];
        if (dup.el && dup.el.parentNode) dup.el.parentNode.removeChild(dup.el);
        delete quests[rawId];
      }
      // If a card exists for rawId but not yet for aliased id, migrate it to aliased key
      if (rawId && rawId !== id && quests[rawId] && !quests[id]){
        quests[id] = quests[rawId];
        delete quests[rawId];
        if (quests[id].el) quests[id].el.setAttribute('data-quest-id', id);
        return quests[id];
      }
      if (quests[id]) return quests[id];
      const el = document.createElement('div'); el.className = 'quest';
      const icon = p.quest_type==='slay'?'‚öîÔ∏è':(p.quest_type==='escort'?'üõ°Ô∏è':'üì¶');
      el.innerHTML = `<div class="title">${icon} ${p.quest_type} <span class="muted" style="margin-left:auto">${p.points} pts ¬∑ w${p.weight||1}</span></div>
      <div class="meta"><span class="status tag warn">Ready</span> ¬∑ assigned to <span class="who">Unassigned</span></div>
      <div class="progress"><div class="bar"></div></div>
      <div class="muted" style="margin-top:6px"><small>timeline:</small><ul class="tl" style="margin:6px 0 0 14px; padding:0; list-style:none"></ul></div>`;
      el.setAttribute('data-quest-id', id);
      (questsByType[p.quest_type] || questsByType['gather']).prepend(el);
      el.addEventListener('click', ()=>openQuestModal(id, p.quest_type));
      const obj = { el, start: Date.now(), dur: Math.max(500, Math.round((p.work_sec||1)*1000)) };
      quests[id] = obj; return obj;
    }

    function tick() {
      const now = Date.now();
      Object.values(quests).forEach(q => {
        const pct = Math.max(0, Math.min(100, Math.round(((now - q.start) / q.dur) * 100)));
        const bar = q.el.querySelector('.bar'); if (bar) bar.style.width = pct + '%';
      });
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    // activity sparkline
    const act = { ts: [], online: [] };
    const thr = { ts: [], perPlayer: {}, colors: {} };
    function drawActivity(){
      const canvas = document.getElementById('activity');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0,0,canvas.width, canvas.height);
      if (act.ts.length < 2) return;
      const maxOnline = Math.max(1, ...act.online);
      const w = canvas.width, h = canvas.height, n = act.ts.length;
      ctx.strokeStyle = '#6fe0a0'; ctx.beginPath();
      act.online.forEach((v,i) => {
        const x = (i/(n-1))*w;
        const y = h - (v/maxOnline)*h;
        if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      });
      ctx.stroke();
    }

    function drawThroughput(){
      const canvas = document.getElementById('throughput');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0,0,canvas.width, canvas.height);
      const colors = ['#6fe0a0','#8ec6ff','#ffd26f','#ff9b9b','#9b59b6','#f39c12','#1abc9c'];
      const players = Object.keys(thr.perPlayer);
      const maxY = Math.max(1, ...players.flatMap(p=>thr.perPlayer[p]||[0]));
      players.forEach((p,idx)=>{
        thr.colors[p] = thr.colors[p] || colors[idx % colors.length];
        ctx.strokeStyle = thr.colors[p]; ctx.beginPath();
        const series = thr.perPlayer[p]||[]; const n = series.length;
        ctx.beginPath();
        series.forEach((v,i)=>{
          const x = (i/(Math.max(1,n-1)))*canvas.width;
          const y = canvas.height - (v/maxY)*canvas.height;
          if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        });
        ctx.stroke();
      });
      // legend
      const legend = document.getElementById('throughput-legend');
      legend.innerHTML = players.map(p=>`<span style="display:inline-flex; align-items:center; gap:6px; margin-right:10px"><span style="width:10px; height:10px; background:${thr.colors[p]}; display:inline-block; border-radius:2px"></span>${p}</span>`).join('');
    }

    function setStatus(el, label, cls){ const st=el.querySelector('.status'); if(st){ st.textContent=label; st.className = `status tag ${cls}`; } }
    function addTL(el, type, text){ const tl = el && el.querySelector('.tl'); if (!tl) return; const li = document.createElement('li'); const tag = document.createElement('span'); tag.className = `tag ${type}`; tag.textContent = type.toUpperCase(); const span = document.createElement('span'); span.textContent = ' ' + text; li.appendChild(tag); li.appendChild(span); tl.appendChild(li); }
    function addHist(id, ts, type, text){ historyByQuest[id] = historyByQuest[id]||[]; historyByQuest[id].push({ts,type,text}); }
    
    function addChaosTimelineEvent(player, eventType, description) {
      console.log(`[CHAOS] Adding ${eventType} event for ${player}: ${description}`);
      
      // Find all quest cards that are assigned to this player (including completed ones)
      // and add chaos events to their timelines if they were recently processed
      let eventsAdded = 0;
      for (const questId in quests) {
        const quest = quests[questId];
        // Check if this quest is assigned to the player
        // For chaos events, we want to show them even on completed quests
        // if they were involved in the chaos (recent processing)
        if (quest.assigned_to === player) {
          const questCard = document.querySelector(`[data-quest-id="${questId}"]`);
          if (questCard) {
            // For disconnect events, always add to any active quest by this player
            // For reconnect events, add to any quest that was recently processed
            let shouldAddEvent = false;
            
            if (eventType === 'disconnect') {
              // Add disconnect to any quest assigned to this player (active or recently completed)
              shouldAddEvent = true;
            } else if (eventType === 'reconnect' || eventType === 'reconnect_failed') {
              // Add reconnect events to quests that were recently processed (within last 30 seconds)
              const now = Date.now() / 1000;
              const recentThreshold = 30; // seconds
              const history = historyByQuest[questId] || [];
              const hasRecentActivity = history.some(h => (now - h.ts) < recentThreshold);
              shouldAddEvent = hasRecentActivity || !quest.status.match(/completed|failed/i);
            }
            
            if (shouldAddEvent) {
              let emoji, text, className;
              if (eventType === 'disconnect') {
                emoji = '‚ö†Ô∏è';
                text = `CHAOS: ${player} disconnected`;
                className = 'warn';
              } else if (eventType === 'reconnect') {
                emoji = 'üîÑ';
                text = `CHAOS: ${player} reconnected`;
                className = 'ok';
              } else if (eventType === 'reconnect_failed') {
                emoji = '‚ùå';
                text = `CHAOS: ${player} reconnect failed`;
                className = 'err';
              }
              
              // Use the existing addTL function to add timeline entry
              addTL(questCard, className, `${emoji} ${text}`);
              
              // Also add to history for persistence
              const now = Date.now() / 1000;
              addHist(questId, now, className, `${emoji} ${text}`);
              eventsAdded++;
              
              console.log(`[CHAOS] Added ${eventType} to quest ${questId} timeline`);
            }
          } else {
            console.log(`[CHAOS] Quest ${questId} assigned to ${player} but shouldAddEvent=false (status: ${quest.status})`);
          }
        }
      }
      console.log(`[CHAOS] Total chaos events added: ${eventsAdded}`);
    }
    
    function fmtTs(ts){ const d=new Date(ts*1000); return d.toLocaleTimeString(); }
    function openQuestModal(id, type){ const modal=document.getElementById('quest-modal'); const head=document.getElementById('qm-header'); const body=document.getElementById('qm-body'); head.textContent = `${id} (${type})`; const hist=historyByQuest[id]||[]; body.innerHTML = hist.map(h=>`[${fmtTs(h.ts)}] ${h.type.toUpperCase()} ${h.text}`).join('\n'); modal.classList.add('show'); }
    document.getElementById('qm-close').onclick=()=>document.getElementById('quest-modal').classList.remove('show');
    const lastEventByQuest = {}; // questId -> drop|requeue|dlq

    const wsProto = location.protocol === 'https:' ? 'wss' : 'ws';
    const ws = new WebSocket(`${wsProto}://${location.host}/ws`);
    
    // RabbitMQ Direct WebSocket Connection for educational introspection
    const rmqWs = new WebSocket(`${wsProto}://${location.host}/ws/rabbitmq`);
    let rmqQueues = [];
    
    rmqWs.onmessage = (ev) => {
      const msg = JSON.parse(ev.data);
      
      if (msg.type === 'rabbitmq_queues') {
        rmqQueues = msg.data || [];
        updateRmqQueueStats(msg.data);
        updateQueueSelector(msg.data);
      } else if (msg.type === 'rabbitmq_topology') {
        updateRmqTopology(msg.exchanges, msg.bindings);
      } else if (msg.type === 'live_message') {
        addLiveMessage(msg);
      } else if (msg.type === 'message_history') {
        displayMessageHistory(msg.messages);
      } else if (msg.type === 'error') {
        console.error('RabbitMQ WebSocket error:', msg.message);
      }
    };
    
    rmqWs.onerror = (err) => {
      console.error('RabbitMQ WebSocket connection error:', err);
      document.getElementById('rmq-queue-stats').innerHTML = '<div style="color:#e74c3c">RabbitMQ connection failed</div>';
    };
    
    function updateRmqQueueStats(queues) {
      const container = document.getElementById('rmq-queue-stats');
      if (!queues || queues.length === 0) {
        container.innerHTML = '<div class="muted">No game queues found</div>';
        return;
      }
      
      const lines = queues.map(q => {
        const name = q.name || 'unknown';
        const ready = q.messages_ready || 0;
        const unacked = q.messages_unacknowledged || 0;
        const consumers = q.consumers || 0;
        const state = q.state || 'unknown';
        
        return `<div style="margin-bottom:2px">
          <span style="color:#6fe0a0">${name}</span>
          <span style="color:#8aa0c7">ready:</span><span style="color:#ffd26f">${ready}</span>
          <span style="color:#8aa0c7">unacked:</span><span style="color:#ff9b9b">${unacked}</span>
          <span style="color:#8aa0c7">consumers:</span><span style="color:#8ec6ff">${consumers}</span>
          <span style="color:#8aa0c7">[${state}]</span>
        </div>`;
      }).join('');
      
      container.innerHTML = lines;
    }
    
    function updateRmqTopology(exchanges, bindings) {
      const container = document.getElementById('rmq-topology');
      if (!exchanges || !bindings) {
        container.innerHTML = '<div class="muted">No topology data</div>';
        return;
      }
      
      const lines = [];
      exchanges.forEach(ex => {
        if (ex.name && ex.name !== '') {
          lines.push(`<div style="color:#6fe0a0; margin-bottom:2px">Exchange: ${ex.name} (${ex.type})</div>`);
          const exBindings = bindings.filter(b => b.source === ex.name);
          exBindings.forEach(b => {
            lines.push(`<div style="margin-left:12px; color:#8aa0c7; font-size:10px">
              ‚Üí ${b.destination} [${b.routing_key || 'no-key'}]
            </div>`);
          });
        }
      });
      
      container.innerHTML = lines.join('') || '<div class="muted">No bindings found</div>';
    }
    
    function updateQueueSelector(queues) {
      const select = document.getElementById('rmq-queue-select');
      select.innerHTML = '<option value="">Select queue...</option>';
      (queues || []).forEach(q => {
        const option = document.createElement('option');
        option.value = q.name;
        option.textContent = `${q.name} (${q.messages_ready || 0} ready)`;
        select.appendChild(option);
      });
    }
    
    let liveMessageCount = 0;
    const MAX_LIVE_MESSAGES = 30;
    
    function addLiveMessage(messageData) {
      // Process message for raw mode calculations
      processRawMessage(messageData);
      
      const container = document.getElementById('rmq-live-stream');
      const timestamp = new Date(messageData.timestamp * 1000).toLocaleTimeString();
      const source = messageData.source || 'unknown';
      const routingKey = messageData.routing_key || 'no-key';
      
      // Color code by source
      let sourceColor = '#8aa0c7';
      if (source === 'publish') sourceColor = '#6fe0a0';  // Green for outgoing
      else if (source === 'scoreboard_consumer') sourceColor = '#ff9b9b';  // Red for incoming
      else if (source.includes('worker')) sourceColor = '#8ec6ff';  // Blue for workers
      
      const messageDiv = document.createElement('div');
      messageDiv.style.marginBottom = '4px';
      messageDiv.style.borderBottom = '1px solid #1e2a4d';
      messageDiv.style.paddingBottom = '2px';
      messageDiv.innerHTML = `
        <div style="display:flex; justify-content:space-between; align-items:center">
          <span style="color:${sourceColor}; font-weight:bold">${source}</span>
          <span style="color:#8aa0c7; font-size:9px">${timestamp}</span>
        </div>
        <div style="color:#ffd26f; font-size:9px; margin:1px 0">${routingKey}</div>
        <div style="color:#e7eeff; font-size:9px; max-height:40px; overflow-y:auto">
          ${JSON.stringify(messageData.payload, null, 1).replace(/\\n/g, '').substring(0, 200)}${JSON.stringify(messageData.payload).length > 200 ? '...' : ''}
        </div>
      `;
      
      container.appendChild(messageDiv);
      liveMessageCount++;
      
      // Limit number of displayed messages
      while (liveMessageCount > MAX_LIVE_MESSAGES) {
        container.removeChild(container.firstElementChild);
        liveMessageCount--;
      }
      
      // Auto-scroll to bottom
      container.scrollTop = container.scrollHeight;
    }
    
    function displayMessageHistory(messages) {
      const container = document.getElementById('rmq-live-stream');
      container.innerHTML = '';
      liveMessageCount = 0;
      
      if (!messages || messages.length === 0) {
        container.innerHTML = '<div class="muted">No recent messages</div>';
        return;
      }
      
      messages.forEach(msg => addLiveMessage(msg));
    }
    
    // Client-side raw data processing for educational purposes
    let rawModeEnabled = false;
    let clientSideStats = {
      scoreboard: {},
      player_stats: {},
      processed_results: new Set()
    };
    
    function processRawMessage(messageData) {
      if (!rawModeEnabled) return;
      
      const payload = messageData.payload;
      const eventStage = payload.event_stage || '';
      const player = payload.player || '';
      const points = parseInt(payload.points || 0);
      const caseId = payload.case_id;
      
      // Client-side processing - direct from RabbitMQ messages
      if (eventStage.endsWith('COMPLETED') && caseId && !clientSideStats.processed_results.has(caseId) && player) {
        clientSideStats.processed_results.add(caseId);
        clientSideStats.scoreboard[player] = (clientSideStats.scoreboard[player] || 0) + points;
        
        // Update player stats
        if (!clientSideStats.player_stats[player]) {
          clientSideStats.player_stats[player] = { accepted: 0, completed: 0, failed: 0 };
        }
        clientSideStats.player_stats[player].completed += 1;
        
        // Update UI with raw calculations
        updateRawModeUI();
      } else if (eventStage.endsWith('FAILED') && caseId && !clientSideStats.processed_results.has(caseId) && player) {
        clientSideStats.processed_results.add(caseId);
        
        if (!clientSideStats.player_stats[player]) {
          clientSideStats.player_stats[player] = { accepted: 0, completed: 0, failed: 0 };
        }
        clientSideStats.player_stats[player].failed += 1;
        
        updateRawModeUI();
      }
    }
    
    function updateRawModeUI() {
      if (!rawModeEnabled) return;
      
      // Update scores with client-side calculations
      const scoresDiv = document.getElementById('scores');
      if (scoresDiv) {
        const sortedScores = Object.entries(clientSideStats.scoreboard)
          .sort(([,a], [,b]) => b - a)
          .slice(0, 10);
          
        scoresDiv.innerHTML = sortedScores.map(([player, score]) => {
          const stats = clientSideStats.player_stats[player] || {};
          return `<div class="score-row">
            <span>${player}</span>
            <span class="badge">${score}</span>
            <span style="font-size:10px; color:#8aa0c7">
              C:${stats.completed || 0} F:${stats.failed || 0}
            </span>
          </div>`;
        }).join('') || '<div class="muted">No scores yet (raw mode)</div>';
      }
      
      // Show raw mode indicator
      document.getElementById('worker-mode').innerHTML = 
        rawModeEnabled ? 'üê∞ Raw RabbitMQ Mode' : 'üöÄ Go workers ready';
    }
    
    // RabbitMQ-derived metrics mode - enable by default for educational value
    let rmqDerivedMode = true;
    
    // Raw mode toggle handler
    document.getElementById('raw-mode-toggle').onchange = function() {
      rawModeEnabled = this.checked;
      
      if (rawModeEnabled) {
        // Disable RabbitMQ-derived mode when raw mode is enabled
        document.getElementById('rmq-derived-toggle').checked = false;
        rmqDerivedMode = false;
        
        // Reset client-side calculations
        clientSideStats = {
          scoreboard: {},
          player_stats: {},
          processed_results: new Set()
        };
        
        alert('üê∞ Raw RabbitMQ Mode Enabled\n\nScoreboard now calculated client-side from raw RabbitMQ messages.\nThis demonstrates minimal abstraction for educational purposes.');
      } else {
        alert('üöÄ Standard Mode Enabled\n\nReturning to server-aggregated data.');
      }
      
      updateRawModeUI();
    };
    
    // RabbitMQ-derived toggle handler
    document.getElementById('rmq-derived-toggle').onchange = function() {
      rmqDerivedMode = this.checked;
      
      if (rmqDerivedMode) {
        // Disable raw mode when RabbitMQ-derived mode is enabled
        document.getElementById('raw-mode-toggle').checked = false;
        rawModeEnabled = false;
        
        // Start polling RabbitMQ for derived metrics
        startRmqDerivedPolling();
        
        alert('üìä RabbitMQ-Derived Metrics Enabled\n\nAll metrics now calculated directly from RabbitMQ Management API.\nThis shows how to derive application state from broker internals.');
      } else {
        stopRmqDerivedPolling();
        alert('üöÄ Standard Mode Enabled\n\nReturning to server-aggregated data.');
      }
      
      updateModeIndicator();
    };
    
    let rmqPollingInterval = null;
    
    function startRmqDerivedPolling() {
      stopRmqDerivedPolling(); // Clear any existing interval
      
      rmqPollingInterval = setInterval(async () => {
        try {
          // Get RabbitMQ-derived metrics
          const metricsResponse = await fetch('/api/rabbitmq/derived/metrics');
          const metricsResult = await metricsResponse.json();
          
          // Get RabbitMQ-derived scoreboard
          const scoreResponse = await fetch('/api/rabbitmq/derived/scoreboard');
          const scoreResult = await scoreResponse.json();
          
          if (metricsResult.ok && scoreResult.ok) {
            updateUIFromRabbitMQ(metricsResult.metrics, scoreResult.data);
          }
        } catch (e) {
          console.error('RabbitMQ polling error:', e);
        }
      }, 2000); // Poll every 2 seconds
    }
    
    function stopRmqDerivedPolling() {
      if (rmqPollingInterval) {
        clearInterval(rmqPollingInterval);
        rmqPollingInterval = null;
      }
    }
    
    function updateUIFromRabbitMQ(metrics, scoreData) {
      // Update pending/unacked counters from RabbitMQ
      document.getElementById('status-pending').textContent = metrics.total_pending || 0;
      
      // Update type metrics from RabbitMQ queue states
      const typeMetricsDiv = document.getElementById('type-metrics');
      if (metrics.per_type) {
        const parts = [];
        Object.entries(metrics.per_type).forEach(([type, stats]) => {
          parts.push(`${type}: P${stats.pending||0} A${stats.accepted||0} D${stats.completed||0} F${stats.failed||0}`);
        });
        typeMetricsDiv.textContent = parts.join('  ¬∑  ');
      }
      
      // Defensively check for scoreData before proceeding
      if (!scoreData) {
        console.warn("Polling received empty or invalid scoreData, skipping UI update.");
        return;
      }
      
      // Update scoreboard from RabbitMQ-derived data
      if (scoreData.scoreboard) {
        const scoresDiv = document.getElementById('scores');
        if (scoresDiv) {
          const sortedScores = Object.entries(scoreData.scoreboard)
            .sort(([,a], [,b]) => b - a)
            .slice(0, 10);
            
          scoresDiv.innerHTML = sortedScores.map(([player, score]) => {
            const stats = scoreData.player_stats[player] || {};
            return `<div class="score-row">
              <span>${player}</span>
              <span class="badge">${score}</span>
              <span style="font-size:10px; color:#8aa0c7">
                C:${stats.completed || 0} F:${stats.failed || 0}
              </span>
            </div>`;
          }).join('') || '<div class="muted">No scores yet (RabbitMQ-derived)</div>';
        }
      }
      
      // Update roster from actual RabbitMQ consumers
      if (scoreData.roster) {
        updateRosterFromRabbitMQ(scoreData.roster);
      }
    }
    
    function updateRosterFromRabbitMQ(rabbitMQRoster) {
      const rosterDiv = document.getElementById('roster');
      if (!rosterDiv) return;
      
      const entries = Object.entries(rabbitMQRoster);
      if (entries.length === 0) {
        rosterDiv.innerHTML = '<div class="muted">No active consumers in RabbitMQ</div>';
        return;
      }
      
      rosterDiv.innerHTML = entries.map(([workerName, workerInfo]) => {
        const queueList = (workerInfo.queues || []).map(q => q.split('.').pop()).join(', ');
        return `<div class="pill go-worker" style="margin-bottom:4px">
          <div class="line1">
            <span class="name">${workerName}</span>
            <span class="dot online"></span>
            <span class="type-badge">RMQ</span>
          </div>
          <div class="line2" style="font-size:11px; color:#8aa0c7">
            Consumers: ${workerInfo.consumer_count || 0} | Queues: ${queueList || 'none'}
          </div>
        </div>`;
      }).join('');
    }
    
    function updateModeIndicator() {
      const indicator = document.getElementById('worker-mode');
      if (rmqDerivedMode) {
        indicator.innerHTML = 'üìä RabbitMQ-Derived Mode';
      } else if (rawModeEnabled) {
        indicator.innerHTML = 'üê∞ Raw RabbitMQ Mode';
      } else {
        indicator.innerHTML = 'üöÄ Go workers ready';
      }
    }
    
    function updateDataSourceIndicator(msg) {
      const sourceElement = document.getElementById('current-data-source');
      if (!sourceElement) return;
      
      let sourceText = 'Standard';
      let sourceColor = '#8aa0c7';
      
      if (rmqDerivedMode) {
        sourceText = 'RabbitMQ-Derived';
        sourceColor = '#6fe0a0';
      } else if (rawModeEnabled) {
        sourceText = 'Raw Messages';
        sourceColor = '#ffd26f';
      } else if (msg.source) {
        // Check if the WebSocket message includes source information
        if (msg.source === 'direct_rabbitmq') {
          sourceText = 'RabbitMQ API';
          sourceColor = '#6fe0a0';
        } else if (msg.source === 'app_state') {
          sourceText = 'App State';
          sourceColor = '#ff9b9b';
        } else if (msg.source.includes('fallback')) {
          sourceText = 'Fallback';
          sourceColor = '#ffd26f';
        }
      }
      
      sourceElement.textContent = sourceText;
      sourceElement.style.color = sourceColor;
    }
    
    // Message peek functionality
    document.getElementById('rmq-peek-btn').onclick = async () => {
      const queueName = document.getElementById('rmq-queue-select').value;
      if (!queueName) {
        document.getElementById('rmq-messages').innerHTML = '<div style="color:#e74c3c">Please select a queue first</div>';
        return;
      }
      
      try {
        const response = await fetch(`/api/rabbitmq/raw/messages/${queueName}?count=5`);
        const result = await response.json();
        
        if (result.ok && result.messages) {
          const container = document.getElementById('rmq-messages');
          if (result.messages.length === 0) {
            container.innerHTML = '<div class="muted">No messages in queue</div>';
          } else {
            const lines = result.messages.map((msg, i) => {
              const payload = JSON.stringify(JSON.parse(msg.payload), null, 2);
              return `<div style="border-bottom:1px solid #1e2a4d; padding:4px 0; margin-bottom:4px">
                <div style="color:#6fe0a0; font-size:11px">Message ${i+1}:</div>
                <div style="color:#8aa0c7; font-size:9px">Routing: ${msg.routing_key || 'none'}</div>
                <pre style="margin:2px 0; color:#e7eeff; font-size:9px; white-space:pre-wrap">${payload}</pre>
              </div>`;
            }).join('');
            container.innerHTML = lines;
          }
        } else {
          document.getElementById('rmq-messages').innerHTML = `<div style="color:#e74c3c">Error: ${result.error}</div>`;
        }
              } catch (e) {
          document.getElementById('rmq-messages').innerHTML = `<div style="color:#e74c3c">Failed to fetch messages: ${e.message}</div>`;
        }
      };
    
    // Initialize RabbitMQ-derived mode on page load
    document.addEventListener('DOMContentLoaded', function() {
      if (rmqDerivedMode) {
        startRmqDerivedPolling();
        updateModeIndicator();
      }
    });
    
    // update quick-add hover titles from stats
    function updateQuickTitles(msg){
      const stats = msg.player_stats || {}; const sb = msg.scoreboard || {}; const r = msg.roster || {};
      const alice = document.getElementById('add-alice'); const bob = document.getElementById('add-bob');
      const fmt = (name) => {
        const s = stats[name] || {accepted:0, completed:0, failed:0};
        const pts = sb[name] || 0; const status = (r[name]&&r[name].status)||'offline';
        const meta = r[name]||{}; const spd = meta.speed_multiplier!=null?meta.speed_multiplier:1.0; const wrk = meta.workers!=null?meta.workers:1;
        return `${name} ‚Äî ${status}\nworkers: ${wrk}  speed: ${spd}\naccepted: ${s.accepted}  completed: ${s.completed}  failed: ${s.failed}\npoints: ${pts}`;
      };
      if (alice) alice.title = fmt('alice'); if (bob) bob.title = fmt('bob');
    }

    // update worker status indicator in header
    function updateWorkerStatus(msg) {
      const workerModeEl = document.getElementById('worker-mode');
      if (!workerModeEl) return;
      
      const roster = msg.roster || {};
      
      // Count workers (all Go workers in this system)
      const workerCount = Object.keys(roster).length;
      
      if (workerCount > 0) {
        workerModeEl.innerHTML = `üöÄ Go workers (${workerCount})`;
      } else {
        workerModeEl.innerHTML = 'üöÄ Go workers ready';
      }
    }

    ws.onmessage = (ev) => {
      const msg = JSON.parse(ev.data);
      
      // Update data source indicator
      updateDataSourceIndicator(msg);
      
      renderScores(msg); renderRoster(msg);
      updateQuickTitles(msg);
      updateChaosPlayerOptions(msg.roster);
      updateWorkerStatus(msg);
      // aggregates per type
        if (msg.metrics && msg.metrics.per_type){
        const parts = [];
        Object.entries(msg.metrics.per_type).forEach(([t,m]) => {
          parts.push(`${t}: P${m.pending||0} A${m.accepted||0} D${m.completed||0} F${m.failed||0}`);
        });
        typeMetricsDiv.textContent = parts.join('  ¬∑  ');
        if (msg.metrics.total_pending!=null){
          document.getElementById('status-pending').textContent = String(msg.metrics.total_pending);
        }
          if (msg.metrics.total_expired!=null){
            document.getElementById('status-expired').textContent = String(msg.metrics.total_expired);
          }
      }

      // activity: count truly online players (not disconnected, reconnecting, etc.)
      const onlineCount = Object.values(msg.roster||{}).filter(r => r.status === 'online').length;
      if (msg.type==='tick'){
        act.ts.push(msg.payload.ts); act.online.push(onlineCount);
        while (act.ts.length > 60) { act.ts.shift(); act.online.shift(); }
        drawActivity();
        // throughput: rate of completion (delta per tick) by player
        const ps = msg.player_stats || {};
        Object.keys(ps).forEach(p=>{ 
          if (!thr.perPlayer[p]) thr.perPlayer[p] = [];
          if (!thr.lastCompleted) thr.lastCompleted = {};
        });
        Object.entries(ps).forEach(([p,st])=>{
          const completed = st.completed || 0;
          const lastCompleted = thr.lastCompleted[p] || 0;
          const delta = Math.max(0, completed - lastCompleted); // Rate of completion this tick
          thr.perPlayer[p].push(delta);
          thr.lastCompleted[p] = completed;
          if (thr.perPlayer[p].length > 60) thr.perPlayer[p].shift();
        });
        drawThroughput();
        // Update card game UI from tick
        if (msg.payload.game_active !== undefined) {
          updateCardGameUI({
            active: msg.payload.game_active,
            score: msg.payload.game_score || 1000,
            timer: msg.payload.card_timer || 0,
            active_effects: []
          });
        }
      }

      if (msg.type === 'master_wave_started') {
        appendFeed('info', 'MASTER', `Wave: ${msg.payload.count} quests @ ${msg.payload.delay}s`);
      } else if (msg.type === 'quest_issued') {
        const p = msg.payload; const id = questId(p); const existed = !!quests[id];
        const qc = ensureQuestCard(p);
        appendFeed('info', 'QUEST', `${p.quest_type} (${p.difficulty}) worth ${p.points} pts${p.reissue_of? ' (reissue)': ''}${p.unroutable?' ¬∑ UNROUTABLE':''}`);
        addHist(id, msg.ts, p.unroutable ? 'err' : 'info', p.unroutable ? 'unroutable' : (p.reissue_of ? 're-issued' : 'issued'));
        const tl = qc.el && qc.el.querySelector('.tl');
        if (tl){ const li = document.createElement('li'); li.textContent = p.unroutable ? 'unroutable' : (p.reissue_of ? 're-issued' : 'issued'); tl.appendChild(li); }
        if (qc.el){
          // Reset assignment and visuals on reissue
          qc.el.querySelector('.who').textContent = 'Unassigned';
          qc.el.classList.remove('done');
          qc.el.classList.remove('fail');
          if (p.unroutable) qc.el.classList.add('unrout'); else qc.el.classList.remove('unrout');
          const bar = qc.el.querySelector('.bar'); if (bar) bar.style.width = '0%';
          if (p.unroutable) setStatus(qc.el, 'Unroutable', 'err'); else setStatus(qc.el, 'Ready', 'warn');
          const qobj = quests[id]; if (qobj){ qobj.start = Date.now(); qobj.dur = Math.max(500, Math.round((p.work_sec||1)*1000)); }
        }
      } else if (msg.type === 'player_online') {
        const p = msg.payload; rosterState[p.player] = {...(rosterState[p.player]||{}), status:'online'}; renderRoster({roster: rosterState});
        appendFeed('info', 'PLAYER', `${p.player} online`);
        // Activity updates only on tick events for proper pacing
      } else if (msg.type === 'player_reconnecting') {
        const p = msg.payload; rosterState[p.player] = {...(rosterState[p.player]||{}), status:'reconnecting'}; renderRoster({roster: rosterState});
        appendFeed('warn', 'PLAYER', `${p.player} reconnecting`);
        // Activity updates only on tick events for proper pacing
      } else if (msg.type === 'player_disconnected') {
        const p = msg.payload; 
        rosterState[p.player] = {...(rosterState[p.player]||{}), status:'disconnected'}; 
        renderRoster({roster: rosterState});
        appendFeed('err', 'PLAYER', `${p.player} CRASHED mid-processing (message will be redelivered)`);
        // Activity updates only on tick events for proper pacing
      } else if (msg.type === 'player_accept') {
        const p = msg.payload; const q = ensureQuestCard(p); if (q.el){
          const whoEl = q.el.querySelector('.who');
          const prev = whoEl.textContent;
          if (prev && prev !== 'Unassigned' && prev !== p.player){
            const reason = lastEventByQuest[questId(p)] === 'drop' ? 'disconnected' : (lastEventByQuest[questId(p)] === 'requeue' ? 'requeued' : 'returned');
            addTL(q.el, 'warn', `${prev} ${reason} ‚Üí Ready`);
          }
          whoEl.textContent = p.player;
          setStatus(q.el, 'Unacked', 'ok');
        }
        appendFeed('ok', 'ACCEPT', `${p.player} -> ${questId(p)} (${p.quest_type}) ${p.difficulty}`);
        if (q && q.el){ addTL(q.el, 'ok', `accepted by ${p.player}`); }
        addHist(questId(p), msg.ts, 'ok', `accepted by ${p.player}`);
      } else if (msg.type === 'player_skip') {
        const p = msg.payload; appendFeed('warn', 'SKIP', `${p.player} ignored ${p.quest_id} (${p.quest_type})`, `${p.player}:${p.quest_id}`);
        const q = ensureQuestCard({ case_id: p.quest_id, quest_type: p.quest_type, points: 0, difficulty: 'medium' });
        if (q.el){ addTL(q.el, 'warn', `${p.player} skipped`); addTL(q.el, 'info', `re-issued`); }
        addHist(p.quest_id, msg.ts, 'warn', `${p.player} skipped`); addHist(p.quest_id, msg.ts, 'info', 're-issued');
      } else if (msg.type === 'msg_drop') {
        const p = msg.payload; const q = ensureQuestCard(p); if (q.el){ addTL(q.el, 'warn', `${p.player} disconnected before ack`); addTL(q.el, 'info', `re-issued`); lastEventByQuest[questId(p)] = 'drop'; }
        addHist(questId(p), msg.ts, 'warn', `${p.player} disconnected before ack`); addHist(questId(p), msg.ts, 'info', 're-issued');
        if (chaosActiveGlobal==='drop'){ chaosActiveGlobal=null; updateChaosUI(); }
      } else if (msg.type === 'msg_requeue') {
        const p = msg.payload; const q = ensureQuestCard(p); if (q.el){ addTL(q.el, 'warn', `${p.player} NACK requeue`); addTL(q.el, 'info', `re-issued`); lastEventByQuest[questId(p)] = 'requeue'; }
        addHist(questId(p), msg.ts, 'warn', `${p.player} NACK requeue`); addHist(questId(p), msg.ts, 'info', 're-issued');
        if (chaosActiveGlobal==='requeue'){ chaosActiveGlobal=null; updateChaosUI(); }
      } else if (msg.type === 'msg_dlq') {
        const p = msg.payload; const q = ensureQuestCard(p); if (q.el){ addTL(q.el, 'err', `${p.player} NACK to DLQ`); lastEventByQuest[questId(p)] = 'dlq'; }
        addHist(questId(p), msg.ts, 'err', `${p.player} NACK to DLQ`);
        if (chaosActiveGlobal==='dlq'){ chaosActiveGlobal=null; updateChaosUI(); }
      } else if (msg.type === 'result_done') {
        const p = msg.payload; const q = quests[questId(p)]; if (q && q.el){
          q.el.classList.add('done'); q.el.querySelector('.bar').style.width = '100%';
          q.el.querySelector('.who').textContent = p.player || (q.el.querySelector('.who').textContent);
          setStatus(q.el, 'Completed', 'ok');
        }
        appendFeed('ok', 'DONE', `${p.player} completed ${p.quest_type} (+${p.points} pts)`);
        if (q && q.el){ addTL(q.el, 'ok', `completed by ${p.player}`); }
        addHist(questId(p), msg.ts, 'ok', `completed by ${p.player}`);
        if (chaosActiveGlobal==='fail_early'){ chaosActiveGlobal=null; updateChaosUI(); }
      } else if (msg.type === 'result_fail') {
        const p = msg.payload; const q = quests[questId(p)]; if (q && q.el){
          q.el.classList.add('fail'); q.el.querySelector('.bar').style.width = '100%';
          q.el.querySelector('.who').textContent = p.player || (q.el.querySelector('.who').textContent);
          setStatus(q.el, 'Failed', 'err');
        }
        appendFeed('err', 'FAIL', `${p.player} failed ${p.quest_type}`);
        if (q && q.el){ addTL(q.el, 'err', `failed by ${p.player}`); }
        addHist(questId(p), msg.ts, 'err', `failed by ${p.player}`);
        if (chaosActiveGlobal==='fail_early'){ chaosActiveGlobal=null; updateChaosUI(); }
      } else if (msg.type === 'roster') {
        // roster snapshot
        renderRoster(msg);
        // Activity updates only on tick events for proper pacing
      } else if (msg.type === 'routing_mode') {
        const mode = (msg.payload&&msg.payload.mode) || msg.routing_mode || 'skill';
        setRoutingActive(mode);
      } else if (msg.type === 'reset') {
        // Clear UI state completely
        document.getElementById('type-metrics').textContent = '';
        document.getElementById('status-pending').textContent = '0';
        document.getElementById('status-expired').textContent = '0';
        document.getElementById('scores').innerHTML = '';
        document.getElementById('roster').innerHTML = '<div class="muted">No players yet</div>';
        
        // Clear all quest elements
        Object.values(quests).forEach(q=>{ if(q.el && q.el.parentNode){ q.el.parentNode.removeChild(q.el); } });
        for (const k in quests) delete quests[k];
        document.getElementById('quest-list').innerHTML = '';
        
        // Clear activity and throughput data
        act.ts = []; act.online = [];
        thr.ts = []; thr.perPlayer = {}; thr.colors = {}; thr.lastCompleted = {};
        
        // Clear charts
        const ac = document.getElementById('activity').getContext('2d'); ac.clearRect(0,0,300,80);
        const thrc = document.getElementById('throughput').getContext('2d'); thrc.clearRect(0,0,300,100);
        
        // Reset roster state
        rosterState = {};
        
        // Allow re-adding preset characters
        document.querySelectorAll('.bio').forEach(b => b.classList.remove('added'));
        
        // If this is a hard reset, reload the page
        if (msg.payload && msg.payload.hard_reset) {
          appendFeed('warn', 'RESET', 'Hard reset - reloading page...');
          setTimeout(() => {
            window.location.href = window.location.href.split('?')[0] + '?t=' + Date.now();
          }, 500);
        }
      } else if (msg.type === 'card_drawn') {
        showCard(msg.payload.card);
        appendFeed('warn', 'CARD', `${msg.payload.card.color.toUpperCase()}: ${msg.payload.card.name}`);
      } else if (msg.type === 'card_applied') {
        appendFeed('info', 'EFFECT', `Applied: ${msg.payload.card.name}`);
      } else if (msg.type === 'card_expired') {
        appendFeed('info', 'EFFECT', `Expired: ${msg.payload.type}`);
      } else if (msg.type === 'card_game_started') {
        appendFeed('info', 'CARD GAME', `Challenge started! Duration: ${msg.payload.duration}s`);
      } else if (msg.type === 'card_game_stopped') {
        appendFeed('info', 'CARD GAME', `Challenge ended. Final score: ${msg.payload.final_score}`);
      } else if (msg.type === 'round_ended') {
        appendFeed('info', 'CARD GAME', `Round completed! Score: ${msg.payload.score} | Duration: ${Math.round(msg.payload.duration)}s`);
      } else if (msg.type === 'chaos_triggered') {
        const p = msg.payload;
        appendFeed('warn', 'CHAOS', `Triggered: ${p.action} on ${p.player} (${p.quest_type} ${p.quest_id})`);
        // Disarm after trigger
        chaosConfig.enabled = false;
        updateChaosUI();
      } else if (msg.type === 'chaos_auto_trigger') {
        const p = msg.payload;
        appendFeed('info', 'CHAOS', `Auto-trigger: publishing ${p.count} ${p.quest_type} for ${p.action}`);
      } else if (msg.type === 'scenario_step') {
        const p = msg.payload;
        appendFeed('info', 'SCENARIO', `Step ${p.step}: ${p.desc}`);
      } else if (msg.type === 'scenario_complete') {
        const p = msg.payload;
        appendFeed('ok', 'SCENARIO', `Completed: ${p.name}`);
      } else if (msg.type === 'chaos_disconnect') {
        const p = msg.payload;
        appendFeed('warn', 'CHAOS', `‚ö†Ô∏è ${p.player} disconnected: ${p.description}`);
        // Add disconnect event to quest timeline if we have a current quest
        addChaosTimelineEvent(p.player, 'disconnect', p.description);
      } else if (msg.type === 'chaos_reconnect') {
        const p = msg.payload;
        appendFeed('ok', 'CHAOS', `üîÑ ${p.player} reconnected: ${p.description}`);
        // Add reconnect event to quest timeline if we have a current quest
        addChaosTimelineEvent(p.player, 'reconnect', p.description);
      } else if (msg.type === 'chaos_reconnect_failed') {
        const p = msg.payload;
        appendFeed('err', 'CHAOS', `‚ùå ${p.player} reconnect failed: ${p.description}`);
        // Add failed reconnect event to quest timeline if we have a current quest
        addChaosTimelineEvent(p.player, 'reconnect_failed', p.description);
      }
    };

    function setRoutingActive(mode){
      const a = document.getElementById('route-skill');
      const b = document.getElementById('route-player');
      a.classList.remove('active'); b.classList.remove('active');
      if (mode==='skill') a.classList.add('active'); else b.classList.add('active');
      document.getElementById('status-routing').textContent = mode;
      document.getElementById('status-routing').className = 'tag info';
    }
    document.getElementById('start-master').onclick = async () => {
      const count = parseInt(document.getElementById('count').value, 10);
      const delay = parseFloat(document.getElementById('delay').value);
      await fetch('/api/master/start', { method: 'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({count, delay}) });
      document.getElementById('status-wave').textContent = `count=${count} ¬∑ delay=${delay}s`;
    };
    // Quick Play buttons
    document.getElementById('qp-quick').onclick = async () => {
      await fetch('/api/players/quickstart', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({preset:'alice_bob'})});
      const count = 20, delay = 0.1;
      await fetch('/api/master/start', { method: 'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({count, delay}) });
      document.getElementById('status-wave').textContent = `count=${count} ¬∑ delay=${delay}s`;
      appendFeed('info','PLAY',`Quick Start: Alice+Bob ¬∑ ${count}@${delay}s`);
    };
    document.querySelectorAll('.qp-preset').forEach(btn=>{
      btn.onclick = () => {
        const c = parseInt(btn.getAttribute('data-count')||'20',10);
        const d = parseFloat(btn.getAttribute('data-delay')||'0.1');
        document.getElementById('count').value = String(c);
        document.getElementById('delay').value = String(d);
        document.getElementById('status-wave').textContent = `count=${c} ¬∑ delay=${d}s`;
      };
    });

    function selectedSkills(){
      const arr = [];
      if (document.getElementById('sk_gather').checked) arr.push('gather');
      if (document.getElementById('sk_slay').checked) arr.push('slay');
      if (document.getElementById('sk_escort').checked) arr.push('escort');
      return arr.join(',');
    }

    document.getElementById('toggle-custom').onclick = () => {
      const cf = document.getElementById('custom-form');
      cf.style.display = cf.style.display==='none' ? '' : 'none';
    };

    document.getElementById('start-player').onclick = async () => {
      const player = document.getElementById('player').value.trim();
      const skills = selectedSkills();
      const fail_pct = parseFloat(document.getElementById('fail').value);
      const speed_multiplier = parseFloat(document.getElementById('speed').value);
      const workers = parseInt(document.getElementById('workers').value, 10);
      const prefetch = parseInt(document.getElementById('prefetch').value, 10);
      const drop_rate = parseFloat(document.getElementById('drop_rate').value);
      const skip_rate = parseFloat(document.getElementById('skip_rate').value);
      await fetch('/api/player/start', { method: 'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({player, skills, fail_pct, speed_multiplier, workers, prefetch, drop_rate, skip_rate}) });
      appendFeed('info','PLAYERS',`Started ${player} (${skills})`);
    };
    // Quickstart
    document.getElementById('quick-alice-bob').onclick = async () => {
      await fetch('/api/players/quickstart', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({preset:'alice_bob'})});
      appendFeed('info','PLAYERS','Started Alice and Bob');
    };
    // Click-to-add bios
    document.querySelectorAll('.bio').forEach(bio=>{
      bio.onclick = async (e) => {
        // Ignore clicks on bubbles
        if (e.target.closest('.bubble')) return;
        const player = bio.getAttribute('data-player');
        const skills = bio.getAttribute('data-skills')||'';
        const fail = parseFloat(bio.getAttribute('data-fail')||'0.2');
        const speed = parseFloat(bio.getAttribute('data-speed')||'1.0');
        const workers = parseInt(bio.getAttribute('data-workers')||'1', 10);
        if (bio.classList.contains('added')){ return; }
        bio.classList.add('added');
        const resp = await fetch('/api/players/quickstart', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({preset:'custom', players:[{player, skills, fail_pct:fail, speed_multiplier:speed, workers}]})});
        const data = await resp.json().catch(()=>({ok:false}));
        if (!data.ok){ appendFeed('warn','PLAYERS',`Could not add ${player}${data.error?': '+data.error:''}`); return; }
        appendFeed('info','PLAYERS',`Started ${player}`);
      };
    });
    document.getElementById('add-random').onclick = async () => {
      const names = ['lara','neo','trinity','morpheus','ripley','sarah','t-800','arthur','diana'];
      const skills = ['gather','slay','escort'];
      const pick = (arr)=>arr[Math.floor(Math.random()*arr.length)];
      const name = pick(names) + Math.floor(Math.random()*100);
      const sk = Array.from(new Set([pick(skills), pick(skills)])).join(',');
      const fail = Math.random()*0.4;
      const speed = 0.5 + Math.random()*1.5;
      const workers = 1 + Math.floor(Math.random()*3);
      await fetch('/api/players/quickstart', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({preset:'custom', players:[{player:name, skills:sk, fail_pct:fail, speed_multiplier:speed, workers:workers}]})});
      appendFeed('info','PLAYERS',`Started ${name} (${sk})`);
    };
    document.getElementById('sc-routing').onclick = async () => {
      await fetch('/api/scenario/run', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({name:'routing_comparison'})});
      appendFeed('info','SCENARIO','Routing comparison: skill vs player-based routing behavior');
    };
    const scLate = document.getElementById('sc-late-bind');
    if (scLate){ scLate.onclick = async () => {
      await fetch('/api/scenario/run', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({name:'late_bind_escort'})});
      appendFeed('info','SCENARIO','Late-bind escort: backlog handoff demo');
    }; }


    function updateCtrlState(){ /* no-op after roster integration */ }
    async function control(action, mode){
      if (!activePlayer) return;
      await fetch('/api/player/control', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({player: activePlayer, action, mode}) });
    }
    // Player pill inline controls
    rosterDiv.addEventListener('click', (e)=>{
      const act = e.target.closest('.player-action');
      if (act){
        const name = act.getAttribute('data-name'); const action = act.getAttribute('data-action');
        if (name && action){ fetch('/api/player/control', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({player:name, action})}); }
        // do NOT change selection when clicking control buttons
        e.stopPropagation(); return;
      }
        const del = e.target.closest('.player-delete');
        if (del){
          const name = del.getAttribute('data-name');
          if (name){ fetch('/api/player/delete', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({player:name})}); }
          e.stopPropagation(); return;
        }
      const pill = e.target.closest('.pill'); if (!pill) return;
      activePlayer = pill.getAttribute('data-name');
      renderRoster({roster: rosterState, player_stats:{}});
    });

    const help = document.getElementById('help');
    document.getElementById('help-btn').onclick = () => help.classList.add('show');
    document.getElementById('close-help').onclick = () => help.classList.remove('show');
    const scoresModal = document.getElementById('scores-modal');
    document.getElementById('scores-btn').onclick = () => scoresModal.classList.add('show');
    document.getElementById('close-scores').onclick = () => scoresModal.classList.remove('show');
    
    // Throughput help toggle
    document.getElementById('throughput-help').onclick = () => {
      alert('Throughput Graph Explanation:\n\n' +
            '‚Ä¢ Shows per-player completion rate over time\n' +
            '‚Ä¢ Each line represents one worker/player\n' +
            '‚Ä¢ Y-axis: Number of quests completed per time period\n' +
            '‚Ä¢ X-axis: Time progression (60 data points)\n' +
            '‚Ä¢ Colors match the player legend below\n' +
            '‚Ä¢ Higher peaks = faster completion rate\n' +
            '‚Ä¢ This is NOT absolute rate, but trend over time');
    };
    
    document.getElementById('toggle-quests').onclick = () => {
      const ds = document.querySelectorAll('details');
      const anyOpen = Array.from(ds).some(d => d.open);
      ds.forEach(d => d.open = !anyOpen);
    };
    document.getElementById('route-skill').onclick = async () => {
      await fetch('/api/routing/set', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({mode:'skill'})});
      appendFeed('info', 'ROUTING', 'Switched to skill-based queues');
      setRoutingActive('skill');
    };
    document.getElementById('route-player').onclick = async () => {
      await fetch('/api/routing/set', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({mode:'player'})});
      appendFeed('info', 'ROUTING', 'Switched to player-based (fanout+skip)');
      setRoutingActive('player');
    };
    document.getElementById('clear-feed').onclick = () => { feed.innerHTML = ''; seenSkips.clear(); };

    // Failed panel actions (legacy UI) - null guarded
    const listFailedBtn = document.getElementById('list-failed');
    if (listFailedBtn){
      listFailedBtn.onclick = async () => {
        const res = await fetch('/api/failed/list');
        const data = await res.json();
        const el = document.getElementById('failed-list');
        if (!el){ return; }
        if (!data.ok) { el.textContent = 'Error listing failed'; return; }
        if (!data.failed.length) { el.textContent = 'No failed quests'; return; }
        el.innerHTML = data.failed.map(f=>`<div style="display:flex; align-items:center; gap:6px" class="failed-item"><button class="mini-btn failed-retry-one" data-qid="${f.quest_id}" title="Reissue">‚Üª</button><span class="failed-label">${f.quest_id} (${f.quest_type})</span><button class="mini-btn failed-filter" data-qid="${f.quest_id}" title="Show only this">üëÅ</button></div>`).join('');
        el.querySelectorAll('.failed-retry-one').forEach(btn=>{
          btn.onclick = async () => {
            const qid = btn.getAttribute('data-qid');
            await fetch('/api/failed/retry', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({quest_id: qid})});
            appendFeed('info','FAILED',`Reissued ${qid}`);
            const again = document.getElementById('list-failed'); if (again) again.click();
          };
        });
        el.querySelectorAll('.failed-filter').forEach(btn=>{
          btn.onclick = () => {
            const qid = btn.getAttribute('data-qid');
            const current = Array.from(el.querySelectorAll('.failed-item'));
            current.forEach(div=>{ if (div.querySelector('.failed-retry-one').getAttribute('data-qid') !== qid) div.style.display='none'; });
            const showAll = document.createElement('button'); showAll.className='mini-btn'; showAll.textContent='Show all'; showAll.onclick=()=>{ const b=document.getElementById('list-failed'); if (b) b.click(); }; el.appendChild(showAll);
          };
        });
      };
    }
    // Guard legacy handlers if present
    const retryFailedBtn = document.getElementById('retry-failed');
    if (retryFailedBtn){ retryFailedBtn.onclick = async () => {
      const res = await fetch('/api/failed/retry', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({})});
      const data = await res.json();
      appendFeed('info','FAILED',`Retried ${data.count||0} failed quests`);
      const fl = document.getElementById('failed-list'); if (fl) fl.textContent = 'No failed quests';
    }; }
    // Unified Messages panel
    let msgTab = 'pending';
    const msgListEl = document.getElementById('msg-list');
    function renderMsg(items, type){
      msgListEl.innerHTML = items.map(it=>{
        if (type==='unrout'){
          const rk = it.routing_key||'?'; const payload = it.payload||{}; const id = payload.case_id||'(no id)';
          return `<div style="display:flex; align-items:center; gap:6px" class="msg-item" data-qid="${id}"><button class="mini-btn unrout-retry" data-id="${id}" title="Reissue (same id)">‚Üª</button><span class="msg-label">rk=${rk} ¬∑ ${id}</span></div>`;
        }
        const id = it.quest_id; const qt = it.quest_type; const age = (it.age_sec!=null?` ¬∑ age ${it.age_sec}s`:'');
        return `<div style="display:flex; align-items:center; gap:6px" class="msg-item" data-qid="${id}"><button class="mini-btn msg-reissue" data-qid="${id}" title="Reissue">‚Üª</button><span class="msg-label">${id} (${qt})${age}</span><button class="mini-btn msg-filter" data-qid="${id}" title="Show only this">üëÅ</button></div>`;
      }).join('');
      // wiring
      msgListEl.querySelectorAll('.msg-reissue').forEach(btn=>{
        btn.onclick = async ()=>{
          const qid = btn.getAttribute('data-qid');
          if (msgTab==='pending') await fetch('/api/pending/reissue',{method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({quest_id: qid})});
          if (msgTab==='failed') await fetch('/api/failed/retry',{method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({quest_id: qid})});
          if (msgTab==='dlq') await fetch('/api/dlq/requeue',{method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({quest_id: qid})});
          appendFeed('info', msgTab.toUpperCase(), `Reissued ${qid}`);
          loadTab(msgTab);
        };
      });
      msgListEl.querySelectorAll('.unrout-retry').forEach(btn=>{
        btn.onclick = async ()=>{
          const id = btn.getAttribute('data-id');
          await fetch('/api/unroutable/reissue', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({quest_id: id})});
          appendFeed('info','UNROUT','Reissued ' + id);
          loadTab('unrout');
        };
      });
      msgListEl.querySelectorAll('.msg-filter').forEach(btn=>{
        btn.onclick = ()=>{
          const qid = resolveAlias(btn.getAttribute('data-qid'));
          Array.from(msgListEl.querySelectorAll('.msg-item')).forEach(div=>{ if (div.getAttribute('data-qid')!==qid) div.style.display='none'; });
          const showAll = document.createElement('button'); showAll.className='mini-btn'; showAll.textContent='Show all'; showAll.onclick=()=>loadTab(msgTab); msgListEl.appendChild(showAll);
          // Filter quest board
          document.querySelectorAll('.quest').forEach(card=>{
            const cid = card.getAttribute('data-quest-id');
            card.style.display = (cid===qid)?'':'none';
          });
        };
      });
    }
    function setMsgTabActive(tab){ ['pending','failed','dlq','unrout'].forEach(t=>{ const el = document.getElementById('tab-'+t); if (el){ if (t===tab) el.classList.add('active'); else el.classList.remove('active'); } }); }
    async function loadTab(tab){
      msgTab = tab;
      setMsgTabActive(tab);
      let items = [];
      if (tab==='pending'){
        const r = await fetch('/api/pending/list'); const d = await r.json();
        if (!d.ok){ msgListEl.textContent='Error'; return; }
        items = d.pending||[];
      } else if (tab==='failed'){
        const r = await fetch('/api/failed/list'); const d = await r.json();
        if (!d.ok){ msgListEl.textContent='Error'; return; }
        items = d.failed||[];
      } else if (tab==='dlq'){
        const r = await fetch('/api/dlq/list'); const d = await r.json();
        if (!d.ok){ msgListEl.textContent='Error'; return; }
        items = d.items||[];
      } else if (tab==='unrout'){
        const r = await fetch('/api/unroutable/list'); const d = await r.json();
        if (!d.ok){ msgListEl.textContent='Error'; return; }
        items = d.items||[];
      }
      renderMsg(items, tab);
    }
    document.getElementById('tab-pending').onclick = ()=>loadTab('pending');
    document.getElementById('tab-failed').onclick = ()=>loadTab('failed');
    document.getElementById('tab-dlq').onclick = ()=>loadTab('dlq');
    const tabUnr = document.getElementById('tab-unrout'); if (tabUnr) tabUnr.onclick = ()=>loadTab('unrout');
    document.getElementById('msg-reissue-all').onclick = async ()=>{
      if (msgTab==='pending') await fetch('/api/pending/reissue',{method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({})});
      if (msgTab==='failed') await fetch('/api/failed/retry',{method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({})});
      if (msgTab==='dlq') await fetch('/api/dlq/requeue',{method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({})});
      if (msgTab==='unrout') await fetch('/api/unroutable/reissue',{method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({})});
      loadTab(msgTab);
    };
    document.getElementById('msg-purge').onclick = async ()=>{
      if (msgTab!=='dlq'){ appendFeed('warn','DLQ','Purge only for DLQ'); return; }
      await fetch('/api/dlq/purge',{method:'POST'}); loadTab('dlq');
    };
    document.getElementById('msg-show-all').onclick = ()=>{
      loadTab(msgTab);
      document.querySelectorAll('.quest').forEach(card=>{ card.style.display=''; });
    };
    // load default tab
    loadTab('pending');
    // TTL setter
    const ttlBtn = document.getElementById('ttl-set'); if (ttlBtn){ ttlBtn.onclick = async ()=>{
      const skill = (document.getElementById('ttl-skill').value||'').trim();
      const ttl = parseInt(document.getElementById('ttl-ms').value||'0',10);
      if (!skill || !ttl) return;
      await fetch('/api/retention/set', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({skill, ttl_ms: ttl})});
      appendFeed('info','TTL',`Set ${skill} TTL to ${ttl}ms`);
    }; }
    // Routes panel
    async function refreshRoutes(){
      const el = document.getElementById('routes');
      if (!el) return;
      const r = await fetch('/api/broker/routes'); const d = await r.json();
      if (!d.ok){ el.textContent = 'Error'; return; }
      el.innerHTML = d.routes.map(it=>`<div>${it.routing_key} ‚Üí ${it.queue}</div>`).join('');
    }
    const refreshBtn = document.getElementById('refresh-routes'); if (refreshBtn){ refreshBtn.onclick = refreshRoutes; refreshRoutes(); }
    // Keyboard shortcuts
    document.addEventListener('keydown', async (e) => {
      const tag = (e.target && (e.target.tagName||'')).toLowerCase();
      if (tag === 'input' || tag === 'textarea') return;
      if (e.ctrlKey || e.metaKey || e.altKey || e.shiftKey) return;
      const k = e.key.toLowerCase();
      if (k === 'w') { document.getElementById('start-master').click(); }
      else if (k === 'q') { document.getElementById('qp-quick').click(); }
      else if (k === 'r') { const b = document.getElementById('add-random'); if (b) b.click(); }
      else if (k === '1') { const b = document.querySelector('.send-one[data-type="gather"]'); if (b) b.click(); }
      else if (k === '2') { const b = document.querySelector('.send-one[data-type="slay"]'); if (b) b.click(); }
      else if (k === '3') { const b = document.querySelector('.send-one[data-type="escort"]'); if (b) b.click(); }
      else if (k === 'p') { const b = document.getElementById('tab-pending'); if (b) b.click(); }
      else if (k === 'f') { const b = document.getElementById('tab-failed'); if (b) b.click(); }
      else if (k === 'd') { const b = document.getElementById('tab-dlq'); if (b) b.click(); }
      else if (k === 'x') {
        const actions = ['drop','requeue','dlq','fail_early','disconnect','pause'];
        const currentAction = document.getElementById('chaos-action').value;
        const currentIndex = actions.indexOf(currentAction);
        const nextAction = actions[(currentIndex + 1) % actions.length];
        
        document.getElementById('chaos-action').value = nextAction;
        document.getElementById('chaos-arm').click();
      }
    });

    // Sync broker KPIs
    document.getElementById('sync-broker').onclick = async () => {
      const res = await fetch('/api/broker/sync'); const data = await res.json();
      if (!data.ok){ appendFeed('err','BROKER',`Sync failed: ${data.error||'unknown'}`); return; }
      document.getElementById('status-broker').textContent = `ready=${data.total_ready} ¬∑ unacked=${data.total_unacked}`;
    };
    // Send one buttons
    document.querySelectorAll('.send-one').forEach(btn=>{
      btn.onclick = async ()=>{
        const t = btn.getAttribute('data-type');
        try {
          const r = await fetch('/api/master/one', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({quest_type: t})});
          const d = await r.json();
          if (!d.ok){ appendFeed('err','MASTER',`Send one failed: ${d.error||'unknown'}`); return; }
          appendFeed('info','MASTER',`Sent one: ${t}`);
        } catch (e) {
          appendFeed('err','MASTER',`Send one error`);
        }
      };
    });
    // Reset app - Hard Reset
    document.getElementById('reset-app').onclick = async () => {
      if (confirm('Hard Reset: Stop all workers, clear cache, and reload UI?')) {
        const response = await fetch('/api/reset', { method:'POST' });
        const result = await response.json();
        appendFeed('warn','RESET', result.message || 'Hard reset completed');
        
        // Clear local UI state
        quests = {};
        rosterState = {};
        act.ts = []; act.online = [];
        thr.ts = []; thr.perPlayer = {}; thr.colors = {};
        
        // Clear browser storage and cache
        try {
          localStorage.clear();
          sessionStorage.clear();
          if ('caches' in window) {
            caches.keys().then(names => names.forEach(name => caches.delete(name)));
          }
        } catch (e) {
          console.log('Cache clearing failed (expected in some browsers):', e);
        }
        
        // Clear displays
        document.getElementById('quest-list').innerHTML = '';
        document.getElementById('roster').innerHTML = '<div class="muted">No players yet</div>';
        document.getElementById('type-metrics').textContent = '';
        document.getElementById('status-pending').textContent = '0';
        document.getElementById('scores').innerHTML = '';
        
        // Clear charts
        const ac = document.getElementById('activity').getContext('2d'); ac.clearRect(0,0,300,80);
        const thrc = document.getElementById('throughput').getContext('2d'); thrc.clearRect(0,0,300,100);
        
        // Force reload with cache busting
        setTimeout(() => {
          window.location.href = window.location.href.split('?')[0] + '?t=' + Date.now();
        }, 1000);
      }
    };
    // Enhanced Chaos System
    let chaosConfig = { enabled: false };
    
    // Update player dropdown with current roster
    function updateChaosPlayerOptions(roster) {
      const select = document.getElementById('chaos-player');
      const currentValue = select.value;
      select.innerHTML = '<option value="">Any Player</option>';
      Object.keys(roster || {}).forEach(player => {
        const option = document.createElement('option');
        option.value = player;
        option.textContent = player;
        select.appendChild(option);
      });
      select.value = currentValue; // Restore selection
    }
    
    // Toggle auto-trigger settings visibility
    document.getElementById('chaos-auto-trigger').onchange = () => {
      const checked = document.getElementById('chaos-auto-trigger').checked;
      document.getElementById('chaos-auto-settings').style.display = checked ? 'block' : 'none';
    };
    
    // Arm chaos button
    document.getElementById('chaos-arm').onclick = async () => {
      const action = document.getElementById('chaos-action').value;
      const target_player = document.getElementById('chaos-player').value || null;
      const target_value = document.getElementById('chaos-quest-type').value || null;
      const auto_trigger = document.getElementById('chaos-auto-trigger').checked;
      const trigger_delay = parseFloat(document.getElementById('chaos-delay').value);
      const trigger_count = parseInt(document.getElementById('chaos-count').value);
      
      // Determine if target is a queue name or quest type
      const isQueue = target_value && target_value.includes('.q');
      const req = {
        action,
        target_player,
        target_queue: isQueue ? target_value : null,
        target_quest_type: !isQueue ? target_value : null,
        auto_trigger,
        trigger_delay,
        trigger_count
      };
      
      try {
        const res = await fetch('/api/chaos/arm', { 
          method: 'POST', 
          headers: {'Content-Type': 'application/json'}, 
          body: JSON.stringify(req)
        });
        const data = await res.json();
        
        if (data.ok) {
          chaosConfig = data.config;
          updateChaosUI();
          const target = target_player ? ` (${target_player})` : '';
          const queue = req.target_queue ? ` queue:${req.target_queue}` : '';
          const quest = req.target_quest_type ? ` type:${req.target_quest_type}` : '';
          const auto = auto_trigger ? ` + auto-publish ${trigger_count} after ${trigger_delay}s` : '';
          const isRmq = action.startsWith('rmq_') ? ' [RabbitMQ-Native]' : ' [App-Level]';
          appendFeed('warn', 'CHAOS', `Armed: ${action}${target}${queue}${quest}${auto}${isRmq}`);
          
          // Show educational note for RabbitMQ-native actions
          if (data.educational_note) {
            appendFeed('info', 'EDUCATIONAL', data.educational_note);
          }
        } else {
          appendFeed('err', 'CHAOS', `Failed to arm: ${data.error}`);
        }
      } catch (err) {
        appendFeed('err', 'CHAOS', 'Failed to arm chaos');
      }
    };
    
    // Disarm chaos button
    document.getElementById('chaos-disarm').onclick = async () => {
      try {
        const res = await fetch('/api/chaos/disarm', { method: 'POST' });
        const data = await res.json();
        
        if (data.ok) {
          chaosConfig = data.config;
          updateChaosUI();
          appendFeed('info', 'CHAOS', 'Disarmed');
        }
      } catch (err) {
        appendFeed('err', 'CHAOS', 'Failed to disarm');
      }
    };
    
    // Update chaos UI based on current config
    function updateChaosUI() {
      const statusDiv = document.getElementById('chaos-status');
      const statusText = document.getElementById('chaos-status-text');
      
      if (chaosConfig.enabled) {
        statusDiv.style.display = 'block';
        statusText.textContent = `Armed: ${chaosConfig.action}`;
        document.getElementById('chaos-arm').style.background = '#f39c12';
        document.getElementById('chaos-disarm').style.background = '#e74c3c';
      } else {
        statusDiv.style.display = 'none';
        document.getElementById('chaos-arm').style.background = '#e74c3c';
        document.getElementById('chaos-disarm').style.background = '#7f8c8d';
      }
    }
    
    // Load initial chaos status
    fetch('/api/chaos/status').then(r => r.json()).then(config => {
      chaosConfig = config;
      updateChaosUI();
    }).catch(() => {});
    
    let chaosActiveGlobal = null; // Legacy variable for compatibility

    // Card Game System
    let cardGameActive = false;
    
    function updateCardGameUI(status) {
      document.getElementById('game-score').textContent = status.score || 1000;
      document.getElementById('card-timer').textContent = status.timer > 0 ? `${status.timer}s` : '--';
      document.getElementById('active-effects').textContent = (status.active_effects || []).length;
      
      // Update button states
      document.getElementById('start-cardgame').disabled = status.active;
      document.getElementById('stop-cardgame').disabled = !status.active;
      document.getElementById('draw-card').disabled = !status.active;
      
      cardGameActive = status.active;
    }
    
    function showCard(card) {
      const cardEl = document.getElementById('current-card');
      const colorBadge = document.getElementById('card-color-badge');
      const nameEl = document.getElementById('card-name');
      const descEl = document.getElementById('card-desc');
      const durationEl = document.getElementById('card-duration');
      
      colorBadge.textContent = card.color.toUpperCase();
      colorBadge.className = `tag card-${card.color}`;
      nameEl.textContent = card.name;
      descEl.textContent = card.desc;
      durationEl.textContent = card.duration > 0 ? `${card.duration}s` : 'Instant';
      
      cardEl.style.display = 'block';
      
      // Auto-hide after 5 seconds
      setTimeout(() => {
        cardEl.style.display = 'none';
      }, 5000);
    }
    
    function updateActiveEffects(effects) {
      const container = document.getElementById('effects-container');
      const listEl = document.getElementById('active-effects-list');
      
      if (effects.length === 0) {
        listEl.style.display = 'none';
        return;
      }
      
      listEl.style.display = 'block';
      container.innerHTML = effects.map(effect => {
        const card = effect.card || {};
        const timeLeft = effect.expires_at > 0 ? Math.max(0, Math.ceil(effect.expires_at - Date.now()/1000)) : 0;
        return `<div class="effect-pill effect-${card.color || 'black'}">
          ${card.name || effect.type} ${timeLeft > 0 ? `(${timeLeft}s)` : ''}
        </div>`;
      }).join('');
    }
    
    // Card Game Event Handlers
    document.getElementById('start-cardgame').onclick = async () => {
      try {
        const res = await fetch('/api/cardgame/start', { method: 'POST' });
        const data = await res.json();
        if (data.ok) {
          appendFeed('info', 'CARD GAME', 'Challenge started! First card in 30s.');
        }
      } catch (err) {
        appendFeed('err', 'CARD GAME', 'Failed to start');
      }
    };
    
    document.getElementById('stop-cardgame').onclick = async () => {
      try {
        const res = await fetch('/api/cardgame/stop', { method: 'POST' });
        const data = await res.json();
        if (data.ok) {
          appendFeed('info', 'CARD GAME', `Challenge ended. Final score: ${data.final_score}`);
        }
      } catch (err) {
        appendFeed('err', 'CARD GAME', 'Failed to stop');
      }
    };
    
    document.getElementById('draw-card').onclick = async () => {
      try {
        const res = await fetch('/api/cardgame/draw', { method: 'POST' });
        const data = await res.json();
        if (data.ok) {
          showCard(data.card);
          appendFeed('info', 'CARD GAME', `Manual draw: ${data.card.name}`);
        }
      } catch (err) {
        appendFeed('err', 'CARD GAME', 'Failed to draw card');
      }
    };
    
    // Initialize card game status (check if enabled first)
    fetch('/api/cardgame/enabled').then(r => r.json()).then(data => {
      if (data.enabled) {
        fetch('/api/cardgame/status').then(r => r.json()).then(updateCardGameUI).catch(() => {});
      } else {
        // Hide card game panel if not enabled
        document.getElementById('cardgame-panel').style.display = 'none';
      }
    }).catch(() => {
      // Hide card game panel if endpoint doesn't exist
      document.getElementById('cardgame-panel').style.display = 'none';
    });

    // Comprehensive DLQ Management System
    
    // Setup DLQ Topology
    document.getElementById('dlq-setup-btn').onclick = async () => {
      try {
        const response = await fetch('/api/dlq/setup', { method: 'POST' });
        const result = await response.json();
        
        if (result.ok) {
          updateDLQStatus('‚úÖ DLQ Topology Setup Complete', result.topology, 'success');
          appendFeed('info', 'DLQ', 'Native RabbitMQ DLQ topology initialized');
        } else {
          updateDLQStatus('‚ùå Setup Failed', { error: result.error }, 'error');
          appendFeed('err', 'DLQ', `Setup failed: ${result.error}`);
        }
      } catch (err) {
        updateDLQStatus('‚ùå Setup Error', { error: err.message }, 'error');
        appendFeed('err', 'DLQ', 'Setup request failed');
      }
    };
    
    // Inspect DLQ System
    document.getElementById('dlq-inspect-btn').onclick = async () => {
      try {
        const response = await fetch('/api/dlq/inspect');
        const result = await response.json();
        
        if (result.ok) {
          updateDLQStatus('üìä DLQ System Analysis', result.dlq_analysis, 'info');
          appendFeed('info', 'DLQ', `Found ${result.dlq_analysis.total_messages} messages across all DLQs`);
        } else {
          updateDLQStatus('‚ùå Inspection Failed', { error: result.error }, 'error');
          appendFeed('err', 'DLQ', `Inspection failed: ${result.error}`);
        }
      } catch (err) {
        updateDLQStatus('‚ùå Inspection Error', { error: err.message }, 'error');
        appendFeed('err', 'DLQ', 'Inspection request failed');
      }
    };
    
    // Replay All DLQ Messages
    document.getElementById('dlq-replay-btn').onclick = async () => {
      if (!confirm('Replay all messages from DLQs back to main queues?')) return;
      
      try {
        const response = await fetch('/api/dlq/replay', { method: 'POST' });
        const result = await response.json();
        
        if (result.ok) {
          updateDLQStatus(`üîÑ Replayed ${result.replayed_count} Messages`, { 
            replayed: result.replayed_count,
            note: 'Messages sent back to main exchange for reprocessing'
          }, 'success');
          appendFeed('info', 'DLQ', `Replayed ${result.replayed_count} messages from DLQs`);
        } else {
          updateDLQStatus('‚ùå Replay Failed', { error: result.error }, 'error');
          appendFeed('err', 'DLQ', `Replay failed: ${result.error}`);
        }
      } catch (err) {
        updateDLQStatus('‚ùå Replay Error', { error: err.message }, 'error');
        appendFeed('err', 'DLQ', 'Replay request failed');
      }
    };
    
    // Purge All DLQ Messages
    document.getElementById('dlq-purge-btn').onclick = async () => {
      if (!confirm('‚ö†Ô∏è DESTRUCTIVE: Purge all DLQ and retry queues? This cannot be undone!')) return;
      
      try {
        const response = await fetch('/api/dlq/purge', { method: 'POST' });
        const result = await response.json();
        
        if (result.ok) {
          updateDLQStatus(`üóëÔ∏è Purged ${result.purged_queues} Queues`, { 
            purged: result.purged_queues,
            note: 'All DLQ and retry messages permanently deleted'
          }, 'warn');
          appendFeed('warn', 'DLQ', `Purged ${result.purged_queues} DLQ queues`);
        } else {
          updateDLQStatus('‚ùå Purge Failed', { error: result.error }, 'error');
          appendFeed('err', 'DLQ', `Purge failed: ${result.error}`);
        }
      } catch (err) {
        updateDLQStatus('‚ùå Purge Error', { error: err.message }, 'error');
        appendFeed('err', 'DLQ', 'Purge request failed');
      }
    };
    
    // Send Test Message to DLQ
    document.getElementById('dlq-test-send').onclick = async () => {
      const reason = document.getElementById('dlq-reason-select').value;
      const messageId = document.getElementById('dlq-test-message').value.trim();
      
      if (!messageId) {
        appendFeed('warn', 'DLQ', 'Please enter a test message ID');
        return;
      }
      
      try {
        // Create a test payload
        const testPayload = {
          case_id: messageId,
          quest_type: 'test',
          player: 'system',
          timestamp: Date.now() / 1000,
          test_message: true,
          failure_reason: reason
        };
        
        // Send to specific DLQ via chaos system for demonstration
        const response = await fetch('/api/chaos/arm', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            action: `send_to_dlq_${reason}`,
            test_payload: testPayload,
            educational_note: `Demonstrating ${reason} failure type routing to specific DLQ`
          })
        });
        
        const result = await response.json();
        
        if (result.ok) {
          appendFeed('info', 'DLQ', `Test message '${messageId}' sent to dlq.${reason}`);
          updateDLQStatus(`üì§ Test Message Sent`, { 
            message_id: messageId,
            reason: reason,
            dlq_queue: `game.quest.dlq.${reason}`
          }, 'info');
          
          // Clear the input
          document.getElementById('dlq-test-message').value = '';
        } else {
          appendFeed('err', 'DLQ', `Failed to send test message: ${result.error}`);
        }
      } catch (err) {
        appendFeed('err', 'DLQ', 'Test message request failed');
      }
    };
    
    // Update DLQ Status Display
    function updateDLQStatus(title, data, type = 'info') {
      const statusDiv = document.getElementById('dlq-status');
      const colors = {
        success: '#6fe0a0',
        error: '#ff9b9b', 
        warn: '#ffd26f',
        info: '#8ec6ff'
      };
      
      let content = `<div style="color:${colors[type]}; font-weight:bold; margin-bottom:6px">${title}</div>`;
      
      if (data.topology) {
        // Display topology setup results
        content += `<div style="color:#e7eeff; margin-bottom:4px">Dead Letter Exchange: <span style="color:#6fe0a0">${data.topology.dead_letter_exchange}</span></div>`;
        content += `<div style="color:#e7eeff; margin-bottom:4px">Alternate Exchange: <span style="color:#6fe0a0">${data.topology.alternate_exchange}</span></div>`;
        content += `<div style="color:#e7eeff; margin-bottom:4px">Retry Queues (${data.topology.retry_queues.length}):</div>`;
        data.topology.retry_queues.forEach(q => {
          content += `<div style="margin-left:12px; color:#ffd26f; font-size:10px">‚Ä¢ ${q.name} (${q.ttl})</div>`;
        });
        content += `<div style="color:#e7eeff; margin-bottom:4px; margin-top:6px">DLQ by Reason (${data.topology.dlq_by_reason.length}):</div>`;
        data.topology.dlq_by_reason.forEach(q => {
          content += `<div style="margin-left:12px; color:#ff9b9b; font-size:10px">‚Ä¢ ${q.name} (${q.reason})</div>`;
        });
      } else if (data.queues) {
        // Display inspection results
        content += `<div style="color:#e7eeff; margin-bottom:6px">Total Messages: <span style="color:#ffd26f">${data.total_messages}</span></div>`;
        
        const categories = { retry: [], dlq: [], quarantine: [] };
        data.queues.forEach(q => {
          const cat = q.category || 'other';
          if (categories[cat]) categories[cat].push(q);
        });
        
        Object.entries(categories).forEach(([category, queues]) => {
          if (queues.length > 0) {
            content += `<div style="color:#8aa0c7; margin-bottom:2px; margin-top:6px">${category.toUpperCase()} Queues:</div>`;
            queues.forEach(q => {
              const status = q.status === 'not_created' ? '(not created)' : `${q.message_count} messages`;
              content += `<div style="margin-left:12px; color:#e7eeff; font-size:10px">‚Ä¢ ${q.name}: ${status}</div>`;
            });
          }
        });
        
        if (data.educational_notes) {
          content += `<div style="margin-top:8px; padding-top:6px; border-top:1px solid #1e2a4d; color:#8aa0c7; font-size:9px">`;
          data.educational_notes.forEach(note => {
            content += `<div style="margin-bottom:2px">‚ÑπÔ∏è ${note}</div>`;
          });
          content += `</div>`;
        }
      } else if (data.error) {
        content += `<div style="color:#ff9b9b">Error: ${data.error}</div>`;
      } else {
        // Display simple data
        Object.entries(data).forEach(([key, value]) => {
          if (key !== 'note') {
            content += `<div style="color:#e7eeff; margin-bottom:2px">${key}: <span style="color:#ffd26f">${value}</span></div>`;
          }
        });
        
        if (data.note) {
          content += `<div style="margin-top:4px; color:#8aa0c7; font-size:10px">${data.note}</div>`;
        }
      }
      
      statusDiv.innerHTML = content;
    }
    
    // Auto-inspect DLQ on page load (if system is already set up)
    setTimeout(() => {
      document.getElementById('dlq-inspect-btn').click();
    }, 2000);
  </script>
</body>
</html>